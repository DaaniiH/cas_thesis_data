---
title: "CAS thesis data"
author: "DaaniiH"
date: 2025-06-01

execute:
  warning: false
format:
  html:
    toc: true
    toc-location: right
    code-fold: true
    code-summary: "Code anzeigen" # Optional, Text für den Aufklapp-Link
    code-tools: true              # Optional, Toolbar für Code-Chunks
    number-sections: true
    max-width: none
editor: visual
editor_options: 
  chunk_output_type: console
number-sections: true
theme: bootstrap
---

# Libraries

```{r}

library(readr)
library(readxl)
library(pxmake)   # Load PX files
library(pxR)      # Load PX files
library(jsonlite) # Load JSON files

library(purrr)

library(writexl)  # Write Excel files

library(dplyr)
library(tidyverse)
library(ggplot2)  # Diagrams
library(ggforce)  # Diagrams
library(DT)       # datatable()

library(DescTools)
```

# Initial data load

## Lookup tables

### Parteinamen

Die verschiedenen Quellen verwenden teils unteschiedliche Parteibezeichnungen. Zur Vereinheitlichung wird deshalb initial eine Lookup Tabelle geladen.

```{r}

# Dataframe bilden aus zwei Vektoren
parteinamen <- data.frame(
  kuerzel = c("fdp", "sps", "svp", "mitte", "evp", "gps", "glp", "ucsp", "pda", "sd", "edu", "fps", "lega", "kvp", "mcg", "cvp", "bdp", "lps", "ldu", "poch", "rep", "eco", "sgv", "sbv", "sgb", "travs", "sav", "vsa", "vpod", "voev", "tcs", "vcs", "acs", "sbk", "ssv", "gem", "kdk", "kkjpd", "gdk", "ldk"),
  
  name = c("Freisinnig-demokratische Partei (FDP.Die Liberalen)", "Sozialdemokratische Partei", "Schweizerische Volkspartei (bis 1936 Parolen der BGB Bern)", "Die Mitte", "Evangelische Volkspartei", "Grüne Partei der Schweiz", "Grünliberale Partei", "Christlichsoziale Partei der Schweiz (von der CVP unabhängige CSP)", "Partei der Arbeit", "Schweizer Demokraten", "Eidgenössisch-Demokratische Union", "Autopartei", "Lega dei Ticinesi", "Katholische Volkspartei", "Mouvement Citoyens Genevois", "Christlichdemokratische Volkspartei", "Bürgerlich-Demokratische Partei", "Liberale Partei der Schweiz", "Landesring der Unabhängigen", "Progressive Organisationen der Schweiz", "Schweizerische Republikanische Bewegung", "Economiesuisse (bis 15.9.2000: Schweizerischer Handels- und Industrieverein SHIV (Vorort))", "Schweizerischer Gewerbeverband", "Schweizer Bauernverband", "Schweizerischer Gewerkschaftsbund", "Travail.Suisse (bis 2002: Parolen des Christlichnationalen Gewerkschaftsbunds (CNG); dieser fusionierte per 1.1.2003 mit der VSA zu Travail.Suisse)", "Schweizerischer Arbeitgeberverband (bis 1996: Zentralverband Schweizerischer Arbeitgeber-Organisationen ZSAO)", "Vereinigung schweizerischer Angestelltenverbände", "Verband des Personals öffentlicher Dienste", "Verband öffentlicher Verkehr", "Touring Club Schweiz", "Verkehrs-Club der Schweiz", "Automobil Club der Schweiz", "Schweizer Bischofskonferenz", "Schweizerischer Städteverband", "Schweizerischer Gemeindeverband", "Konferenz der Kantonsregierungen", "Konferenz der kantonalen Justiz- und Polizeidirektoren", "Schweizerische Gesundheitsdirektorenkonferenz", "Konferenz der kantonalen Landwirtschaftsdirektoren"),
  stringsAsFactors = FALSE)

# Neue Spalte mit "p-" Präfix für späteren Lookup der Parteiparolen
parteinamen$p_kuerzel <- paste0("p-", parteinamen$kuerzel) 

# Parteikürzel in Grossbuchstaben 
parteinamen$kuerzel <-  toupper(parteinamen$kuerzel)

# Spaltenreihenfolge anpassen: p_kuerzel, kuerzel, name
parteinamen <- parteinamen[, c("p_kuerzel", "kuerzel", "name")]

# Anzeige mit datatable()
datatable(parteinamen,
          class = 'nowrap',
          filter = 'top',
          options = list(pageLength = 7,
                         scrollX = TRUE,
                         search = list(regex = TRUE,
                                       caseInsensitive = TRUE)))
```

## Abstimmungen

```{r}

# Schweizweite Abstimmungen
voting_raw <- read_delim("~/CAS/Zertifikatsarbeit/data/votes/abstimmungen_swissvotes_DATASET CSV 09-02-2025.csv",
                     delim = ";",
                     escape_double = FALSE,
                     trim_ws = TRUE,
                     show_col_types = FALSE)

# TODO evt. nur random sample berechnen auf grund Grösse...
datatable(voting_raw,
          class = 'nowrap',
          filter = 'top',
          options = list(pageLength = 7,
                         scrollX = TRUE,
                         search = list(regex = TRUE,
                                       caseInsensitive = TRUE)))

```

## Wahlen

### Bundesebene

#### Nationalrat

```{r}

# # PX-Datei einlesen
# elec_nationalrat_px <- read.px("~/CAS/Zertifikatsarbeit/data/elections/px-x-1702020000_103_BUND_NATIONALRAT.px")
# 
# # View PX Format
# str(elec_nationalrat_px)
# 
# # PX-Objekt in Dataframe umwandeln
# elec_nationalrat <- as.data.frame(elec_nationalrat_px)


# Nationalrat: Daten einlesen
elec_nationalrat  <- read_excel("~/CAS/Zertifikatsarbeit/data/elections/Ratsmitglieder_1848_DE_BUND_NR.xlsx")

str(elec_nationalrat)
```

#### Ständerat

```{r}

# Ständerat: Daten einlesen
elec_ständerat  <- read_excel("~/CAS/Zertifikatsarbeit/data/elections/Ratsmitglieder_1848_DE_BUND_SR.xlsx")

str(elec_ständerat)
```

### Kantonsebene

#### Kantonale Parlamente (Legislative)

```{r}

# TODO Die Kantonalen Abstimmungen finden nicht in allen kantonen gleichzeitg statt. Deshalb genauer die Räte/Konstellation zum Zeitpunkt der jeweiligen Abstimmung zu prüfen.


# Struktur der "schön formatierten" Exceldatei lässt keinen "simplen" Import zu.
# Header ist in Zeile 2 und nicht vollständig
# Daten (für Kantone) starten in Zeile 4 aber enden auf Zeile 29 bevor es mit Kommentaren und Fussnoten weitergeht 


# Header aus Zeile 2 für Spaltennamen lesen
tmp_header <- read_excel("~/CAS/Zertifikatsarbeit/data/elections/je-d-17.02.05.01.03_KANTON_Kantonale_Parlamentswahlen.xlsx", 
                     sheet = 1, 
                     skip = 1,   # Header ist Zeile 2
                     n_max = 0) %>%
  names()

# Lücken im Header anpassen (i.e. erste beiden Spalten benennen)
tmp_header <- c("Kanton", "Leer", tmp_header)

tmp_name_map <- c("Kanton"        = "Kanton",
                  "Leer"          = "Leer",
                  "Wahljahr 5)"   = "Wahljahr",
                  "FDP 2)"        = "FDP",
                  "SP"            = "SP",
                  "SVP"           = "SVP",
                  "LPS 2)"        = "LPS",
                  "EVP"           = "EVP",
                  "CSP"           = "CSP",
                  "GLP"           = "GLP",
                  "Die Mitte 8)"  = "Mitte",
                  "CVP 3) 8)"     = "CVP",
                  "BDP 8)"        = "BDP",
                  "PdA"           = "PdA",
                  "PSA"           = "PSA",
                  "Grüne 9)"      = "Grüne",
                  "FGA"           = "FGA",
                  "Sol."          = "Sol.",
                  "EDU"           = "EDU",
                  "Lega"          = "Lega",
                  "MCG (MCR)"     = "MCR",
                  "Übrige 4)"     = "Übrige",
                  "Total"         = "Total")



# Automatisch ersetzen
tmp_header <- ifelse(tmp_header %in% names(tmp_name_map),
                     tmp_name_map[tmp_header],
                     tmp_header)

print(tmp_header)


# Daten ab Zeile 4 importieren
elec_kantonsparlament_raw <- read_excel("~/CAS/Zertifikatsarbeit/data/elections/je-d-17.02.05.01.03_KANTON_Kantonale_Parlamentswahlen.xlsx", 
                 sheet = 1, 
                 skip = 3,         # überspringt die ersten 3 Zeilen
                 col_names = tmp_header)

# Schritt 4: Nur Zeilen behalten, in denen "Wahljahr" nicht NA ist
elec_kantonsparlament <- elec_kantonsparlament_raw  %>%
  filter(!is.na(Wahljahr)) %>% 
  select(-Leer)

# Ergebnis anzeigen
print(elec_kantonsparlament)
```

#### Kantonale Regierung (Exekutive)

Die Kantonalen Abstimmungen finden nicht in allen kantonen gleichzeitg statt. Deshalb genauer die Räte/Konstellation zum Zeitpunkt der jeweiligen Abstimmung zu prüfen.

Die Struktur der "schön formatierten" Exceldatei lässt keinen "simplen" Import zu.

-   Header ist in Zeile 2 und nicht vollständig

-   Daten (für Kantone) starten in Zeile 4 aber enden auf Zeile 29 bevor es mit Kommentaren und Fussnoten weitergeht.

##### Sheet 1: 2025

```{r}

# Header aus Zeile 2 für Spaltennamen lesen
tmp_header <- read_excel("~/CAS/Zertifikatsarbeit/data/elections/je-d-17.02.06.01_KANTON_Kantonale_Regierungswahlen.xlsx", 
                     sheet = 1, 
                     skip = 1,   # Header ist Zeile 2
                     n_max = 0) %>%
  names()

# Lücken im Header anpassen (i.e. erste Spalten benennen)
tmp_header <- c("Kanton", tmp_header)

tmp_name_map <- c("Kanton"        = "Kanton",
                  "Wahljahr 1"    = "Wahljahr",
                  "FDP 2"         = "FDP",
                  "SP"            = "SP",
                  "SVP"           = "SVP",
                  "LP 2"          = "LPS",
                  "EVP"           = "EVP",
                  "CSP"           = "CSP",
                  "GLP"           = "GLP",
                  "Die Mitte 3"   = "Mitte",
                  "CVP 3"         = "CVP",
                  "BDP 3"         = "BDP",
                  "PdA"           = "PdA",
                  "PSA"           = "PSA",
                  "Grüne 5"       = "Grüne",
                  "FGA"           = "FGA",
                  "Sol."          = "Sol.",
                  "Lega"          = "Lega",
                  "MCG (MCR)"     = "MCR",
                  "Übrige 4"      = "Übrige",
                  "Total"         = "Total")

# Automatisch ersetzen
tmp_header_neu <- ifelse(tmp_header %in% names(tmp_name_map),
                     tmp_name_map[tmp_header],
                     tmp_header)

print(tmp_header_neu)

# Daten ab Zeile 4 importieren
elec_kantonsregierung_raw <- read_excel("~/CAS/Zertifikatsarbeit/data/elections/je-d-17.02.06.01_KANTON_Kantonale_Regierungswahlen.xlsx", 
                 sheet = 1, 
                 skip = 3,         # überspringt die ersten 3 Zeilen
                 col_names = tmp_header_neu)

# Schritt 4: Nur Zeilen behalten, in denen "Wahljahr" nicht NA ist
elec_kantonsregierung_2025 <- elec_kantonsregierung_raw  %>%
  filter(!is.na(Wahljahr)) %>%
  select(Kanton, where(~ {x <- suppressWarnings(as.numeric(.x))
    sum(x, na.rm = TRUE) > 0}))

# Ergebnis anzeigen
print(elec_kantonsregierung_2025)
```

##### Sheet 2: 2024

```{r}


# Header aus Zeile 2 für Spaltennamen lesen
tmp_header <- read_excel("~/CAS/Zertifikatsarbeit/data/elections/je-d-17.02.06.01_KANTON_Kantonale_Regierungswahlen.xlsx", 
                     sheet = 2, 
                     skip = 1,   # Header ist Zeile 2
                     n_max = 0) %>%
  names()

# Lücken im Header anpassen (i.e. erste Spalten benennen)
tmp_header <- c("Kanton", tmp_header)
cat(paste0('"', tmp_header, '"', ","), sep = "\n")

tmp_name_map <- c("Kanton"        = "Kanton",
                  "Wahljahr 1"    = "Wahljahr",
                  "FDP 2"         = "FDP",
                  "SP"            = "SP",
                  "SVP"           = "SVP",
                  "LP 2"          = "LPS",
                  "EVP"           = "EVP",
                  "CSP"           = "CSP",
                  "GLP"           = "GLP",
                  "Die Mitte 3"   = "Mitte",
                  "CVP 3"         = "CVP",
                  "BDP 3"         = "BDP",
                  "PdA"           = "PdA",
                  "PSA"           = "PSA",
                  "Grüne 5"       = "Grüne",
                  "FGA"           = "FGA",
                  "Sol."          = "Sol.",
                  "Lega"          = "Lega",
                  "MCG (MCR)"     = "MCR",
                  "Übrige 4"      = "Übrige",
                  "Total"         = "Total")

# Automatisch ersetzen
tmp_header_neu <- ifelse(tmp_header %in% names(tmp_name_map),
                     tmp_name_map[tmp_header],
                     tmp_header)

print(tmp_header_neu)

# Daten ab Zeile 4 importieren
elec_kantonsregierung_raw <- read_excel("~/CAS/Zertifikatsarbeit/data/elections/je-d-17.02.06.01_KANTON_Kantonale_Regierungswahlen.xlsx", 
                 sheet = 2, 
                 skip = 3,         # überspringt die ersten 3 Zeilen
                 col_names = tmp_header_neu)

# Schritt 4: Nur Zeilen behalten, in denen "Wahljahr" nicht NA ist
elec_kantonsregierung_2024 <- elec_kantonsregierung_raw  %>%
  filter(!is.na(Wahljahr)) %>%
  select(Kanton, where(~ {x <- suppressWarnings(as.numeric(.x))
    sum(x, na.rm = TRUE) > 0}))

# Ergebnis anzeigen
print(elec_kantonsregierung_2024)
```

##### Sheet 3: 2023

```{r}


# Header aus Zeile 2 für Spaltennamen lesen
tmp_header <- read_excel("~/CAS/Zertifikatsarbeit/data/elections/je-d-17.02.06.01_KANTON_Kantonale_Regierungswahlen.xlsx", 
                     sheet = 3, 
                     skip = 1,   # Header ist Zeile 2
                     n_max = 0) %>%
  names()

# Lücken im Header anpassen (i.e. erste Spalten benennen)
tmp_header <- c("Kanton", tmp_header)
cat(paste0('"', tmp_header, '"', ","), sep = "\n")

tmp_name_map <- c("Kanton"        = "Kanton",
                  "Wahljahr 1)"    = "Wahljahr",
                  "FDP 2)"         = "FDP",
                  "SP"            = "SP",
                  "SVP"           = "SVP",
                  "LP 2)"          = "LPS",
                  "EVP"           = "EVP",
                  "CSP"           = "CSP",
                  "GLP"           = "GLP",
                  "Die Mitte 3)"   = "Mitte",
                  "CVP 3)"         = "CVP",
                  "BDP 3)"         = "BDP",
                  "PdA"           = "PdA",
                  "PSA"           = "PSA",
                  "Grüne 5)"       = "Grüne",
                  "FGA"           = "FGA",
                  "Sol."          = "Sol.",
                  "Lega"          = "Lega",
                  "MCG (MCR)"     = "MCR",
                  "Übrige 4)"      = "Übrige",
                  "Total"         = "Total")

# Automatisch ersetzen
tmp_header_neu <- ifelse(tmp_header %in% names(tmp_name_map),
                     tmp_name_map[tmp_header],
                     tmp_header)

print(tmp_header_neu)

# Daten ab Zeile 4 importieren
elec_kantonsregierung_raw <- read_excel("~/CAS/Zertifikatsarbeit/data/elections/je-d-17.02.06.01_KANTON_Kantonale_Regierungswahlen.xlsx", 
                 sheet = 3, 
                 skip = 3,         # überspringt die ersten 3 Zeilen
                 col_names = tmp_header_neu)

# Schritt 4: Nur Zeilen behalten, in denen "Wahljahr" nicht NA ist
elec_kantonsregierung_2023 <- elec_kantonsregierung_raw  %>%
  filter(!is.na(Wahljahr)) %>%
  select(Kanton, where(~ {x <- suppressWarnings(as.numeric(.x))
    sum(x, na.rm = TRUE) > 0}))

# Ergebnis anzeigen
print(elec_kantonsregierung_2023)
```

##### Sheet 4: 2022

```{r}


# Header aus Zeile 2 für Spaltennamen lesen
tmp_header <- read_excel("~/CAS/Zertifikatsarbeit/data/elections/je-d-17.02.06.01_KANTON_Kantonale_Regierungswahlen.xlsx", 
                     sheet = 4, 
                     skip = 1,   # Header ist Zeile 2
                     n_max = 0) %>%
  names()

# Lücken im Header anpassen (i.e. erste Spalten benennen)
tmp_header <- c("Kanton", tmp_header)
cat(paste0('"', tmp_header, '"', ","), sep = "\n")

tmp_name_map <- c("Kanton"        = "Kanton",
                  "Wahljahr 1)"    = "Wahljahr",
                  "FDP 2)"         = "FDP",
                  "SP"            = "SP",
                  "SVP"           = "SVP",
                  "LP 2)"          = "LPS",
                  "EVP"           = "EVP",
                  "CSP"           = "CSP",
                  "GLP"           = "GLP",
                  "Die Mitte 3)"   = "Mitte",
                  "CVP 3)"         = "CVP",
                  "BDP 3)"         = "BDP",
                  "PdA"           = "PdA",
                  "PSA"           = "PSA",
                  "Grüne 6)"       = "Grüne",
                  "FGA"           = "FGA",
                  "Sol."          = "Sol.",
                  "Lega"          = "Lega",
                  "MCR"     = "MCR",
                  "Übrige 4)"      = "Übrige",
                  "Total"         = "Total")

# Automatisch ersetzen
tmp_header_neu <- ifelse(tmp_header %in% names(tmp_name_map),
                     tmp_name_map[tmp_header],
                     tmp_header)

print(tmp_header_neu)

# Daten ab Zeile 4 importieren
elec_kantonsregierung_raw <- read_excel("~/CAS/Zertifikatsarbeit/data/elections/je-d-17.02.06.01_KANTON_Kantonale_Regierungswahlen.xlsx", 
                 sheet = 4, 
                 skip = 3,         # überspringt die ersten 3 Zeilen
                 col_names = tmp_header_neu)

# Schritt 4: Nur Zeilen behalten, in denen "Wahljahr" nicht NA ist
elec_kantonsregierung_2022 <- elec_kantonsregierung_raw  %>%
  filter(!is.na(Wahljahr)) %>%
  select(Kanton, where(~ {x <- suppressWarnings(as.numeric(.x))
    sum(x, na.rm = TRUE) > 0}))

# Ergebnis anzeigen
print(elec_kantonsregierung_2022)

```

##### Sheet 5: 2021

```{r}


# Header aus Zeile 2 für Spaltennamen lesen
tmp_header <- read_excel("~/CAS/Zertifikatsarbeit/data/elections/je-d-17.02.06.01_KANTON_Kantonale_Regierungswahlen.xlsx", 
                     sheet = 5, 
                     skip = 1,   # Header ist Zeile 2
                     n_max = 0) %>%
  names()

# Lücken im Header anpassen (i.e. erste Spalten benennen)
tmp_header <- c("Kanton", tmp_header)
cat(paste0('"', tmp_header, '"', ","), sep = "\n")

tmp_name_map <- c("Kanton"        = "Kanton",
                  "Wahljahr 1)"    = "Wahljahr",
                  "FDP 2)"         = "FDP",
                  "SP"            = "SP",
                  "SVP"           = "SVP",
                  "LP 2)"          = "LPS",
                  "EVP"           = "EVP",
                  "CSP"           = "CSP",
                  "GLP"           = "GLP",
                  "Die Mitte 3)"   = "Mitte",
                  "CVP 3)"         = "CVP",
                  "BDP 5)"         = "BDP",
                  "PdA"           = "PdA",
                  "PSA"           = "PSA",
                  "GPS"       = "Grüne",
                  "FGA"           = "FGA",
                  "Sol."          = "Sol.",
                  "Lega"          = "Lega",
                  "MCR"     = "MCR",
                  "Übrige 4)"      = "Übrige",
                  "Total"         = "Total")

# Automatisch ersetzen
tmp_header_neu <- ifelse(tmp_header %in% names(tmp_name_map),
                     tmp_name_map[tmp_header],
                     tmp_header)

print(tmp_header_neu)

# Daten ab Zeile 4 importieren
elec_kantonsregierung_raw <- read_excel("~/CAS/Zertifikatsarbeit/data/elections/je-d-17.02.06.01_KANTON_Kantonale_Regierungswahlen.xlsx", 
                 sheet = 5, 
                 skip = 3,         # überspringt die ersten 3 Zeilen
                 col_names = tmp_header_neu)

# Schritt 4: Nur Zeilen behalten, in denen "Wahljahr" nicht NA ist
elec_kantonsregierung_2021 <- elec_kantonsregierung_raw  %>%
  filter(!is.na(Wahljahr)) %>%
  select(Kanton, where(~ {x <- suppressWarnings(as.numeric(.x))
    sum(x, na.rm = TRUE) > 0}))

# Ergebnis anzeigen
print(elec_kantonsregierung_2021)

```

##### Sheet 6: 2020

```{r}

# Header aus Zeile 2 für Spaltennamen lesen
tmp_header <- read_excel("~/CAS/Zertifikatsarbeit/data/elections/je-d-17.02.06.01_KANTON_Kantonale_Regierungswahlen.xlsx", 
                     sheet = 6, 
                     skip = 1,   # Header ist Zeile 2
                     n_max = 0) %>%
  names()

# Lücken im Header anpassen (i.e. erste Spalten benennen)
tmp_header <- c("Kanton", tmp_header)
cat(paste0('"', tmp_header, '"', ","), sep = "\n")

tmp_name_map <- c("Kanton"         = "Kanton",
                  "Wahljahr 1)"    = "Wahljahr",
                  "FDP 2)"         = "FDP",
                  "CVP 3)"         = "CVP",
                  "SP"             = "SP",
                  "SVP"            = "SVP",
                  "LP 2)"          = "LPS",
                  "CSP"            = "CSP",
                  "GLP"            = "GLP",
                  "BDP"            = "BDP",
                  "GPS"            = "Grüne",
                  "Lega"           = "Lega",
                  "MCR"            = "MCR",
                  "Übrige 4)"      = "Übrige",
                  "Total"          = "Total")

# Automatisch ersetzen
tmp_header_neu <- ifelse(tmp_header %in% names(tmp_name_map),
                     tmp_name_map[tmp_header],
                     tmp_header)

print(tmp_header_neu)

# Daten ab Zeile 4 importieren
elec_kantonsregierung_raw <- read_excel("~/CAS/Zertifikatsarbeit/data/elections/je-d-17.02.06.01_KANTON_Kantonale_Regierungswahlen.xlsx", 
                 sheet = 6, 
                 skip = 3,         # überspringt die ersten 3 Zeilen
                 col_names = tmp_header_neu)

# Schritt 4: Nur Zeilen behalten, in denen "Wahljahr" nicht NA ist
elec_kantonsregierung_2020 <- elec_kantonsregierung_raw  %>%
  filter(!is.na(Wahljahr)) %>%
  select(Kanton, where(~ {x <- suppressWarnings(as.numeric(.x))
    sum(x, na.rm = TRUE) > 0}))


# Ergebnis anzeigen
print(elec_kantonsregierung_2020)

```

##### Sheet 7: 2019

```{r}


# Header aus Zeile 2 für Spaltennamen lesen
tmp_header <- read_excel("~/CAS/Zertifikatsarbeit/data/elections/je-d-17.02.06.01_KANTON_Kantonale_Regierungswahlen.xlsx", 
                     sheet = 7, 
                     skip = 1,   # Header ist Zeile 2
                     n_max = 0) %>%
  names()

# Lücken im Header anpassen (i.e. erste Spalten benennen)
tmp_header <- c("Kanton", tmp_header)
cat(paste0('"', tmp_header, '"', ","), sep = "\n")

tmp_name_map <- c("Kanton"        = "Kanton",
                  "Wahljahr 1)"    = "Wahljahr",
                  "FDP 2)"         = "FDP",
                  "SP"            = "SP",
                  "SVP"           = "SVP",
                  "LP 2)"          = "LPS",
                  "EVP"           = "EVP",
                  "CSP"           = "CSP",
                  "GLP"           = "GLP",
                  "Die Mitte 3)"   = "Mitte",
                  "CVP 3)"         = "CVP",
                  "BDP 3)"         = "BDP",
                  "PdA"           = "PdA",
                  "PSA"           = "PSA",
                  "Grüne 5)"       = "Grüne",
                  "FGA"           = "FGA",
                  "Sol."          = "Sol.",
                  "Lega"          = "Lega",
                  "MCG (MCR)"     = "MCR",
                  "Übrige 4)"      = "Übrige",
                  "Total"         = "Total")

# Automatisch ersetzen
tmp_header_neu <- ifelse(tmp_header %in% names(tmp_name_map),
                     tmp_name_map[tmp_header],
                     tmp_header)

print(tmp_header_neu)

# Daten ab Zeile 4 importieren
elec_kantonsregierung_raw <- read_excel("~/CAS/Zertifikatsarbeit/data/elections/je-d-17.02.06.01_KANTON_Kantonale_Regierungswahlen.xlsx", 
                 sheet = 7, 
                 skip = 3,         # überspringt die ersten 3 Zeilen
                 col_names = tmp_header_neu)

# Schritt 4: Nur Zeilen behalten, in denen "Wahljahr" nicht NA ist
elec_kantonsregierung_2019 <- elec_kantonsregierung_raw  %>%
  filter(!is.na(Wahljahr)) %>%
  select(Kanton, where(~ {x <- suppressWarnings(as.numeric(.x))
    sum(x, na.rm = TRUE) > 0}))

# Ergebnis anzeigen
print(elec_kantonsregierung_2019)
```

##### Sheets konsolidieren & Change log erstellen

```{r}

# Alle Dataframes in Liste packen
df_list <- list(elec_kantonsregierung_2019,
                elec_kantonsregierung_2020,
                elec_kantonsregierung_2021,
                elec_kantonsregierung_2022,
                elec_kantonsregierung_2023,
                elec_kantonsregierung_2024,
                elec_kantonsregierung_2025)

# Alle Dataframes zusammenführen (Vereinigung aller Spalten)
df_all <- bind_rows(df_list)

# Filter auf relevante Wahljahre setzen (2015, da Legislatur 4-5 Jahre dauert und später der Zeitraum ab 2019 geprüft wird)
df_all <- df_all %>%
  filter(Wahljahr >= 2015, Wahljahr <= 2025)

# Hilfsfuntion um alle Einträge in numerische umzuwandeln
make_numeric <- function(x) suppressWarnings(as.numeric(x))

# Funktion auf alle Spalten ausser Kanton & Wahljahr anwenden.
df_all <- df_all %>%
  mutate(across(-c(Kanton, Wahljahr), make_numeric))

# Pro Kanton+Wahljahr auf eine Zeile reduzieren
df_all <- df_all %>%
  group_by(Kanton, Wahljahr) %>%
  summarise(across(everything(), ~ coalesce(last(na.omit(.)), NA_real_)), .groups = "drop")

# Alle Kantone und Wahljahre eruieren/bestimmen, die in den Daten vorkommen
vektor_kanton <- unique(df_all$Kanton)
vektor_wahljahr <- 2015:2025

# Vollständigen Grid erzeugen
df_grid <- expand_grid(Kanton = vektor_kanton,
                       Wahljahr = vektor_wahljahr)

# Mit den Daten verknüpfen
df_all <- left_join(df_grid,
                    df_all,
                    by = c("Kanton", "Wahljahr"))


elec_kantonsregierung_final <- df_all %>%
  arrange(Kanton, Wahljahr) %>%
  group_by(Kanton) %>%
  fill(everything(), .direction = "down") %>%
  ungroup()


```

### Gemeindeebene

#### Exekutiven der statistischen Städte

-   1 Excelsheet / Jahr

-   Header zweizeilig mit Start in Zeile –\> 3 `skip = 2, n_max = 2,`

-   Teils verbundene Header-Zeilen (vertikal/horizontal)

-   Cluster Einwohnerzahlen unterteilt Daten

-   Parteinamen uneinheitlich aufgrund von Fussnoten

--\> Datenformat "wide" zuerst bereinigen und ins "long" Format bringen

Initialer Code für Einzelimport (ohne Function)

```{r}

#| eval: false
#| echo: true


###################################################################
########## DATEN IMPORTIEREN ######################################
########## Header definieren ######################################
###################################################################


# Headerzeilen einlesen
header <- read_excel("~/CAS/Zertifikatsarbeit/data/elections/je-d-17.02.07.01_GEMEINDE_Die Exekutiven der statistischen Städte.xlsx",
                     sheet = 2,
                     skip = 2,
                     n_max = 2,
                     col_names = FALSE)

# Daten  einlesen
daten_raw <- read_excel("~/CAS/Zertifikatsarbeit/data/elections/je-d-17.02.07.01_GEMEINDE_Die Exekutiven der statistischen Städte.xlsx",
                    sheet= 2,
                    skip = 5,
                    col_names = FALSE)


# Die Spaltennamen zusammensetzen
# Leere Zellen in der ersten Headerzeile mit Werten von rechts auffüllen (falls nötig)
header_filled <- as.data.frame(t(header))   # t() "matrix transpose"
header_filled <- fill(header_filled,        
                      V1,                   # Header Spalte 1 (V1) auffüllen
                      .direction = "down")  # Werte nach unten übernehmen
header_filled <- t(header_filled)           # t() nochmals (zurück)

# Spaltennamen kombinieren
spaltennamen <- paste(header_filled[1, ],
                      header_filled[2, ],
                      sep = "_")
spaltennamen <- gsub("_NA|NA_","", spaltennamen) # Entfernt überflüssige NAs

# Spaltennamen zuweisen
colnames(daten_raw) <- spaltennamen


# Ergebnis: Dataframe mit korrekten Spaltennamen
head(daten_raw)


###################################################################
########## TRANSPONIEREN ##########################################
########## Gemeindegrössen Cluster ################################
###################################################################


# Cluster Einwohnerzahl als Spalte verwenden
daten_wide <- daten_raw %>%
  mutate(Gemeindegrösse_Cluster =            # Name der neuen Spalte
           ifelse(
             is.na(                          # 4) auf NA prüfen
               suppressWarnings(             # 3) Warnung aus (z.B. "≥ ..Einw..")
               as.numeric(                   # 2) Wert als Zahl 
               gsub("'", "", `Kantons-Nr.`)  # 1) Tausender Zeichen (') entfernen
             ))),
             as.character(`Kantons-Nr.`),    # 5) Wert von "Kantons-Nr" oder 
             NA_character_
           ))

# Ansicht (Snapshot) nach transponieren (vor auffülen)
daten_wide[1:10,                    # 10 Zeilen
           c(1:10,                  # 10 Spalten +
             ncol(daten_wide))]     # Letzte Spalte
                                    # ncol() von df daten_wide --> Anz. Spalten
                                    # Anzahl Spalten = Position der letzten Spalte


# 2. Cluster nach unten auffüllen
daten_wide <- daten_wide %>%
  fill(Gemeindegrösse_Cluster, .direction = "down")


# Ansicht (Snapshot) nach transponieren & auffülen
daten_wide[1:10,                    # 10 Zeilen
           c(1:10,                  # 10 Spalten +
             ncol(daten_wide))]     # Letzte Spalte
                                    # ncol() von df daten_wide --> Anz. Spalten
                                    # Anzahl Spalten = Position der letzten Spalte


# Herausfiltern von Zeilen mit NICHT-numerischem Wert in "Kantons-Nr."
daten_wide <- daten_wide %>%
    filter(!is.na(suppressWarnings(as.numeric(gsub("'", "", `Kantons-Nr.`)))))


# Ansicht (Snapshot) nach transponieren & auffüllen
daten_wide[1:10,                    # 10 Zeilen
           c(1:10,                  # 10 Spalten +
             ncol(daten_wide))]     # Letzte Spalte
                                    # ncol() von df daten_wide --> Anz. Spalten
                                    # Anzahl Spalten = Position der letzten Spalte

# Ergebnis prüfen
head(daten_wide)



###################################################################
########## TRANSPONIEREN ##########################################
########## Frauen, Männer, Total & Parteien ## ####################
###################################################################


daten_wide[1:18,                    # 10 Zeilen
           c(1:18,                  # 10 Spalten +
             ncol(daten_wide))]     # Letzte Spalte
                                    # ncol() von df daten_wide --> Anz. Spalten
                                    # Anzahl Spalten = Position der letzten Spalte


daten_long <- daten_wide %>%
  mutate(across(matches("(_Frauen|_Männer|_Total)$"),
                ~ suppressWarnings(as.numeric(.)))) %>%       # Werte numerisch!
           pivot_longer(
             cols = matches("(_Frauen|_Männer|_Total)$"),     # Spaltenauswahl
             names_to = c("Partei", "m_w_Total"),             # Neue Label-Spalte
             names_pattern = "^(.*)_(Frauen|Männer|Total)$",  # RegEx 
             values_to = "Wert")                              # Neue Wert-Spalte


# Ansicht (Snapshot) nach transponieren & auffüllen
daten_long[1:8,
           1:ncol(daten_long)]

```

Dateipfad und gewünschte Sheets festlegen

```{r}

dateipfad <- "~/CAS/Zertifikatsarbeit/data/elections/je-d-17.02.07.01_GEMEINDE_Die Exekutiven der statistischen Städte.xlsx"

selected_sheets <- c("2024", "2023", "2022","2021","2020","2019") 
```

Function für den Import der Gemeindedaten

```{r}

importiere_sheet <- function(dateipfad, sheetname) {

      ###################################################################
      ########## DATEN IMPORTIEREN ######################################
      ########## Header definieren ######################################
      ###################################################################
      
      
      # Headerzeilen einlesen
      header <- suppressMessages(read_excel(dateipfad,
                   sheet = sheetname,
                   skip = 2,
                   n_max = 2,
                   col_names = FALSE))
      
      # Daten  einlesen
      daten_raw <- suppressMessages(read_excel(dateipfad,
                              sheet = sheetname,
                              skip = 5,
                              col_names = FALSE))
      
      
      # Die Spaltennamen zusammensetzen
      # Leere Zellen in 1. Headerzeile mit Werten von rechts auffüllen wenn leer/NA
      header_filled <- as.data.frame(t(header))   # t() "matrix transpose"
      header_filled <- fill(header_filled,        
                            V1,                   # Header Spalte 1 (V1) auffüllen
                            .direction = "down")  # Werte nach unten übernehmen
      header_filled <- t(header_filled)           # t() nochmals (zurück)
      
      # Spaltennamen kombinieren
      spaltennamen <- paste(header_filled[1, ],
                            header_filled[2, ],
                            sep = "_")
      spaltennamen <- gsub("_NA|NA_","", spaltennamen) # Entfernt überflüssige NAs
      
      # Spaltennamen zuweisen
      colnames(daten_raw) <- spaltennamen
      
      
      ###################################################################
      ########## TRANSPONIEREN ##########################################
      ########## Gemeindegrössen Cluster ################################
      ###################################################################
      
      
      # Cluster Einwohnerzahl als Spalte verwenden
      daten_wide <- daten_raw %>%
        mutate(Gemeindegrösse_Cluster =             # Name der neuen Spalte
                 ifelse(
                   is.na(                           # 4) auf NA prüfen
                     suppressWarnings(        # 3) Warnung aus (z.B. "≥ ..Einw..")
                     as.numeric(                    # 2) Wert als Zahl 
                     gsub("'", "", `Kantons-Nr.`)   # 1) Tausender Zeichen (')                                                              entfernen
                   ))),
                   as.character(`Kantons-Nr.`),     # 5) Wert von "Kantons-Nr" 
                   NA_character_                    #    sonst NA   
                 ))  %>%
        fill(Gemeindegrösse_Cluster,
             .direction = "down") %>%              # Cluster nach unten auffüllen
        filter(!is.na(suppressWarnings(
          as.numeric(gsub("'", "", `Kantons-Nr.`))))) # Herausfiltern von Zeilen                                                           mit NICHT-numerischem Wert
    
    
    # Ansicht (Snapshot) nach transponieren
    daten_wide[1:10,                    # 10 Zeilen
               c(1:10,                  # 10 Spalten +
                 ncol(daten_wide))]     # Letzte Spalte
                                        # ncol() von df daten_wide --> Anz. Spalten
                                        # Anzahl Spalten = Position letzte Spalte
    
    
    
    ###################################################################
    ########## TRANSPONIEREN ##########################################
    ########## Frauen, Männer, Total & Parteien ## ####################
    ###################################################################
    
    
    
    daten_long <- daten_wide %>%
      mutate(across(matches("(_Frauen|_Männer|_Total)$"),
                    ~ suppressWarnings(as.numeric(.)))) %>%     # Werte numerisch
      pivot_longer(cols = matches("(_Frauen|_Männer|_Total)$"), # Spaltenauswahl
                   names_to = c("Partei", "m_w_Total"),         # Neue Label-Spalte
                   names_pattern = "^(.*)_(Frauen|Männer|Total)$",  # RegEx
                   values_to = "Wert")                          # Neue Wert-Spalte
    
    return(daten_long)

}



```

Function ausführen: Import der Dateien testen

```{r}

for (sheet in selected_sheets) {
  cat("\n-----------------------------\n")
  cat("Versuche Sheet:", sheet, "\n")
  result <- tryCatch({
    dat <- importiere_sheet(dateipfad, sheet)
    cat("Sheet erfolgreich eingelesen:", sheet, "\n")
    # Zusammenfassung:
    cat("Anzahl Zeilen:", nrow(dat), "\n")
    cat("Anzahl Spalten:", ncol(dat), "\n")
    cat("Spaltennamen (erste 15):", paste(names(dat)[1:min(15, ncol(dat))], collapse = ", "), "\n")
    TRUE
  }, error = function(e) {
    cat("Fehler beim Einlesen von Sheet:", sheet, "\n")
    cat("Fehlermeldung:", e$message, "\n")
    FALSE
  })
}

```

Function ausführen: Import und Konsolidation

```{r}

# Objekt erstellen, mit Sheets als tibble/dataframe
daten_liste <- lapply(selected_sheets,
                      function(sheet) {
                        importiere_sheet(dateipfad, sheet)})
str(daten_liste)
lapply(daten_liste, summary)

# Alle tibbles zu einem Dataframe zusammenfügen
elec_gemeinde_exekutiven_final <- bind_rows(daten_liste, .id = "Sheet")
```

## Parteilandschaft

```{r}

parties_rating <- read_excel("~/CAS/Zertifikatsarbeit/data/parties_economic_socio-political_rating.xlsx",
                             sheet = "matrix_eco-socio_enhanced")
```

# Transformation & visualization

## Abstimmungen

```{r}

voting <- voting_raw %>%
  mutate(datum = as.Date(datum, format = "%d.%m.%Y")) %>%  # Format-Umwandlung
  filter(datum >= as.Date("2019-12-31")) %>%               # Vergleich
  select(anr,                                              # Spalten-Wahl
         datum,
         titel_kurz_d,
         titel_off_d,
         rechtsform, #1 Obligatorisches Referendum
                     #2 Fakultatives Referendum
                     #3 Volksinitiative
                     #4 Direkter Gegenentwurf zu einer Volksinitiative
                     #5 Stichfrage
         dep,
         `br-pos`,   #1 Befürwortend
                     #2 Ablehnend
                     #3 Keine
                     #8 Vorzug für den Gegenentwurf (bei Stichfragen)
                     #9 Vorzug für die Volksinitiative (bei Stichfragen)
                     #. Missing
         legisjahr,
         `pa-iv`,
         `bv-pos`,   #1 Befürwortend
                     #2 Ablehnend
                     #3 Keine Abstimmungsempfehlung des Parlaments
                     #8 Vorzug für den Gegenentwurf (bei Stichfragen)
         `nr-pos`,   #1 Befürwortende Mehrheit im Nationalrat
                     #2 Ablehnende Mehrheit im Nationalrat
                     #3 Keine Abstimmungsempfehlung des Nationalrats
                     #8 Vorzug für den Gegenentwurf (bei Stichfragen)
         nrja,
         nrnein,
         `sr-pos`,   #1 Befürwortende Mehrheit im Ständerat
                     #2 Ablehnende Mehrheit im Ständerat
                     #3 Keine Abstimmungsempfehlung des Ständerats
                     #8 Vorzug für den Gegenentwurf (bei Stichfragen)
         srja,
         srnein,
         starts_with("p-"),
                     #1 Ja-Parole
                     #2 Nein-Parole
                     #3 keine Parole abzugeben
                     #4 empfahl, einen leeren Stimmzettel einzulegen
                     #5 Stimmfreigabe
                     #8 Bevorzugung des Gegenentwurfs (bei Stichfrage)
                     #9 Bevorzugung der Volksinitiative (bei Stichfrage)
                     #66 Neutral: keine Parole oder Empfehlung auf leer einlegen                        #9999 Organisation existiert nicht
                     #. Unbekannt
         volk,       #0 Eine Mehrheit der Abstimmenden hat die Vorlage abgelehnt
                     #1 Eine Mehrheit der Abstimmenden hat die Vorlage angenommen
                     #8 Bei Stichfragen:  Mehrheit für Gegenentwurfs
                     #9 Bei Stichfragen:  Mehrheit Volksinitiative
         stand,
                     #0 Die Vorlage hat keine Mehrheit der Standesstimmen er-reicht
                     #1 Die Vorlage hat die Mehrheit der Standesstimmen erreicht
                     #3 Ständemehr nicht notwendig
                     #8 Bei Stichfragen: Mehrheit für Gegenentwurf
                     #9 Bei Stichfragen: Mehrheit für Volksinitiative
         annahme,    #0 Ablehnung der Vorlage
                     #1 Annahme der Vorlage
                     #8 Bei Stichfragen: Gegenentwurf angenommen
                     #9 Bei Stichfragen: Volksinitiative angenommen
                     #. Bei Stichfragen: Ergebnis der Stichfrage obsolet
         berecht,
         stimmen,
         bet,
         leer,
         ungultig,
         gultig,
         volkja,
         volknein,
         `volkja-proz`)


```

```{r}
grep("^p-", names(voting), value = TRUE)
paste(grep("^p-", names(voting), value = TRUE), collapse = ", ")
```

## Wahlen

### Bundesebene

#### Nationalrat

```{r}

#TODO Es kann innerhalb der Legislatur Wechsel geben --> Anstelle der heute "Aktiven" ist es deshalb genauer die Räte/Konstellation zum Zeitpunkt der jeweiligen Abstimmung zu prüfen. 

# Anzeige mit datatable()
datatable(elec_nationalrat,
          class = 'nowrap',
          filter = 'top',
          options = list(pageLength = 7,
                         scrollX = TRUE,
                         search = list(regex = TRUE,
                                       caseInsensitive = TRUE)))

# Fehlende Werte (NA), Klassen und Levels prüfen
Abstract(elec_nationalrat)
PlotMiss(elec_nationalrat)

# Datensatz reduzieren auf Aktive und doppelte Einträge elimnieren
elec_nationalrat_reduced <- elec_nationalrat %>%
  filter(Active == TRUE) %>% 
  distinct(.keep_all = TRUE) %>% 
  select(CantonAbbreviation,
         CantonName,
         PartyAbbreviation,
         PartyName) %>% 
  mutate(value = 1)

datatable(elec_nationalrat_reduced,
          class = 'nowrap',
          filter = 'top',
          options = list(pageLength = 7,
                         scrollX = TRUE,
                         search = list(regex = TRUE,
                                       caseInsensitive = TRUE)))

# Sitze pro Kanton, Partei und Jahr 
    
    # long format
      df_sum <- elec_nationalrat_reduced %>%
      group_by(CantonAbbreviation, PartyAbbreviation) %>%
      summarise(sum_value = sum(value, na.rm = TRUE),
                .groups = "drop")
    
    # wide format
    # Pivotieren: Partei-Spalten erzeugen
    df_wide <- df_sum %>%
      pivot_wider(names_from = PartyAbbreviation,
                  values_from = sum_value,
                  values_fill = 0)
    
    
    
    # Partei-Spaltennamen extrahieren (ohne Kanton/Jahr)
    partei_cols <- setdiff(names(df_wide),
                           c("CantonAbbreviation"))
    
    # Spaltensummen der Parteien berechnen für Sortierung
    partei_sums <- colSums(df_wide[partei_cols])
    
    # Zeilensumme der Kantone/Jahre hinzufügen
    df_wide$Total <- rowSums(df_wide[partei_cols])
    
    
    # Parteispalten-Anordnung nach Summe sortieren
    sorted_partei <- names(sort(partei_sums,
                                decreasing = TRUE))
    
    
    # Dataframe neu anordnen: Kanton/Jahr,  sortierte und gefilterte Parteien
    elec_nationalrat_final <- df_wide[, c(setdiff(names(df_wide),
                                                  partei_cols),
                                          sorted_partei)] %>% 
      arrange(desc(Total))
    
datatable(elec_nationalrat_final,
          class = 'nowrap',
          filter = 'top',
          options = list(pageLength = 7,
                         scrollX = TRUE,
                         search = list(regex = TRUE,
                                       caseInsensitive = TRUE)))
```

#### Ständerat

```{r}

#TODO Es kann innerhalb der Legislatur Wechsel geben --> Anstelle der heute "Aktiven" ist es deshalb genauer die Räte/Konstellation zum Zeitpunkt der jeweiligen Abstimmung zu prüfen.


# Anzeige mit datatable()
datatable(elec_ständerat,
          class = 'nowrap',
          filter = 'top',
          options = list(pageLength = 7,
                         scrollX = TRUE,
                         search = list(regex = TRUE,
                                       caseInsensitive = TRUE)))


# Fehlende Werte (NA), Klassen und Levels prüfen
Abstract(elec_ständerat)
PlotMiss(elec_ständerat)

# Datensatz reduzieren auf Aktive und doppelte Einträge elimnieren
elec_ständerat_reduced <- elec_ständerat %>%
  filter(Active == TRUE) %>% 
  distinct(.keep_all = TRUE) %>% 
  select(CantonAbbreviation,
         CantonName,
         PartyAbbreviation,
         PartyName) %>% 
  mutate(value = 1)

datatable(elec_ständerat_reduced,
          class = 'nowrap',
          filter = 'top',
          options = list(pageLength = 7,
                         scrollX = TRUE,
                         search = list(regex = TRUE,
                                       caseInsensitive = TRUE)))

# Sitze pro Kanton, Partei und Jahr 
    
    # long format
      df_sum <- elec_ständerat_reduced %>%
      group_by(CantonAbbreviation, PartyAbbreviation) %>%
      summarise(sum_value = sum(value, na.rm = TRUE),
                .groups = "drop")
    
    # wide format
    # Pivotieren: Partei-Spalten erzeugen
    df_wide <- df_sum %>%
      pivot_wider(names_from = PartyAbbreviation,
                  values_from = sum_value,
                  values_fill = 0)
    
    
    # Partei-Spaltennamen extrahieren (ohne Kanton/Jahr)
    partei_cols <- setdiff(names(df_wide),
                           c("CantonAbbreviation"))
    
    # Spaltensummen der Parteien berechnen für Sortierung
    partei_sums <- colSums(df_wide[partei_cols])
    
    # Zeilensumme der Kantone/Jahre hinzufügen
    df_wide$Total <- rowSums(df_wide[partei_cols])
    
    
    # Parteispalten-Anordnung nach Summe sortieren
    sorted_partei <- names(sort(partei_sums,
                                decreasing = TRUE))
    
    
    # Dataframe neu anordnen: Kanton/Jahr,  sortierte und gefilterte Parteien
    elec_ständerat_final <- df_wide[, c(setdiff(names(df_wide),
                                                  partei_cols),
                                        sorted_partei)] %>% 
      arrange(desc(Total))
    
datatable(elec_ständerat_final,
          class = 'nowrap',
          filter = 'top',
          options = list(pageLength = 7,
                         scrollX = TRUE,
                         search = list(regex = TRUE,
                                       caseInsensitive = TRUE)))
```

### Kantonsebene

#### Kantonsparlament

```{r}


```

#### Kantonsregierung

```{r}


datatable(elec_kantonsregierung_final,
         class = 'nowrap',
          filter = 'top',
          options = list(pageLength = 7,
                         scrollX = TRUE,
                         search = list(regex = TRUE,
                                       caseInsensitive = TRUE)))

# Änderungen verfolgen
# Partei-Spalten bestimmen
parteien <- setdiff(names(elec_kantonsregierung_final), c("Kanton", "Wahljahr", "Total"))

# Dataframe nach Kanton und Wahljahr sortieren und ins lange Format bringen
df_long <- elec_kantonsregierung_final %>%
  arrange(Kanton, Wahljahr) %>%
  pivot_longer(
    cols = all_of(parteien),
    names_to = "Partei",
    values_to = "Wert_neu"
  ) %>%
  group_by(Kanton, Partei) %>%
  arrange(Wahljahr, .by_group = TRUE) %>%
  mutate(Wert_alt = lag(Wert_neu)) %>%
  ungroup()

# Änderungen filtern: Zeige nur, wo sich der Wert geändert hat (und nicht NA)
elec_kantonsregierung_changelog <- df_long %>%
  filter(!is.na(Wert_alt),
         Wert_neu != Wert_alt) %>%
  select(Kanton,
         Wahljahr,
         Partei,
         Wert_alt,
         Wert_neu)


datatable(elec_kantonsregierung_changelog,
          class = 'nowrap',
          filter = 'top',
          options = list(pageLength = 7,
                         scrollX = TRUE,
                         search = list(regex = TRUE,
                                       caseInsensitive = TRUE)))
```

### Gemeindeebene

#### Gemeinde

```{r}



```

## Parteilandschaft

### Multi-Dimensions-Model

#### Minimalwerte

Für jede Partei den Minimalwert des Abstimmungsverhaltens zu verwenden, basiert auf der Zielsetzung, die klarste politische Position einer Partei in einem bestimmten Themenbereich zu identifizieren. Diese Methodik stellt sicher, dass auch bei wenigen Abweichungen von der Mehrheitslinie die tatsächliche Haltung der Partei deutlich erkennbar bleibt.

```{r}

ggplot(parties_rating,
       aes(x = eco_pct_min_x,
           y = socio_pct_min_y,
           label = Partei)) +
  geom_point(size = 3) +
  geom_text(vjust = -0.8) +
  geom_segment(aes(x = 50, xend = 50,
                   y = 0, yend = 100), linetype = "dashed", color = "blue") +
  geom_segment(aes(x = 0, xend = 100,
                   y = 50, yend = 50), linetype = "dashed", color = "blue") +
  
  annotate("text",
           x = 0,
           y = min(parties_rating$socio_pct_min_y) + 55,
           label = "Links/staatsgläubig", size = 4, hjust = 0.5) +
  annotate("text",
           x = 100,
           y = min(parties_rating$socio_pct_min_y) + 55,
           label = "Rechts/marktwirtschaftlich", size = 4, hjust = 0.5) +
  annotate("text",
           x = 50,
           y = min(parties_rating$socio_pct_min_y) - 3,
           label = "Autoritär/Konservativ", size = 4, hjust = 0.5) +
  annotate("text",
           x = 50,
           y = min(parties_rating$socio_pct_min_y) + 103,
           label = "Libertär/Progressiv", size = 4, hjust = 0.5) +
  scale_x_continuous(limits = c(0, 100)) +
  labs(x = "Wirtschaftspolitisch",
       y = "Gesellschaftspolitisch",
       title = "Politische Positionierung im Zwei-Achsen-Modell",
       subtitle = "Grundlage: Minimalwerte des Abstimmungsverhaltens") +
  theme_minimal()+
  theme(plot.title = element_text(size = 18,
                                  margin = margin(b = 30)),
        axis.title.x = element_text(size = 14,
                                    margin = margin(t = 5)),
        axis.title.y = element_text(size = 14,
                                    margin = margin(r = 5))) +
  coord_cartesian(ylim = c(0, 105),
                  xlim = c(0, 105),
                  clip = "off")

```

#### Durchschnittswerte als Zentrum und Min/Max als Ellipse

```{r}

ggplot(parties_rating,
       aes(x = eco_pct_avg_x,
           y = socio_pct_avg_y,
           label = Partei)) +
  geom_ellipse(
    aes(x0 = eco_pct_avg_x,
        y0 = socio_pct_avg_y,
        a = (eco_pct_max_x - eco_pct_min_x) / 2, # Halbachse x
        b = (socio_pct_max_y - socio_pct_min_y) / 2, # Halbachse y
        angle = 0),
    fill = "gray80", alpha = 0.4) +
  geom_point(size = 3) +
  geom_text(vjust = -0.8) +
  geom_segment(aes(x = 50, xend = 50,
                   y = 0, yend = 100), linetype = "dashed", color = "blue") +
  geom_segment(aes(x = 0, xend = 100,
                   y = 50, yend = 50), linetype = "dashed", color = "blue") +
  annotate("text",
           x = 0,
           y = min(parties_rating$socio_pct_min_y) + 55,
           label = "Links/staatsgläubig", size = 4, hjust = 0.5) +
  annotate("text",
           x = 100,
           y = min(parties_rating$socio_pct_min_y) + 55,
           label = "Rechts/marktwirtschaftlich", size = 4, hjust = 0.5) +
  annotate("text",
           x = 50,
           y = min(parties_rating$socio_pct_min_y) - 3,
           label = "Autoritär/Konservativ", size = 4, hjust = 0.5) +
  annotate("text",
           x = 50,
           y = min(parties_rating$socio_pct_min_y) + 103,
           label = "Libertär/Progressiv", size = 4, hjust = 0.5) +
  scale_x_continuous(limits = c(-10, +110)) +
  labs(x = "Wirtschaftspolitisch",
       y = "Gesellschaftspolitisch",
       title = "Politische Positionierung im Zwei-Achsen-Modell",
       subtitle = "Grundlage: Durchschnitt des Abstimmungsverhaltens als Zentrum, Min-/Max als Ellipse") +
  theme_minimal()+
  theme(plot.title = element_text(size = 18,
                                  margin = margin(b = 30)),
        axis.title.x = element_text(size = 14,
                                    margin = margin(t = 5)),
        axis.title.y = element_text(size = 14,
                                    margin = margin(r = 5))) +
  coord_cartesian(ylim = c(0, 100),
                  xlim = c(0, 100),
                  clip = "off")
```

#### Hauptparteien: Durchschnittswerte als Zentrum und Min/Max als Ellipse / Klein- und Regionalparteien nur mit ihrem Durchschnittswert

```{r}

ggplot(parties_rating,
       aes(x = eco_pct_avg_x,
           y = socio_pct_avg_y,
           label = Partei)) +
  geom_ellipse(aes(x0 = eco_pct_avg_x,
                   y0 = socio_pct_avg_y,
                   a = (eco_pct_max_x - eco_pct_min_x) / 2, # Halbachse x
                   b = (socio_pct_max_y - socio_pct_min_y) / 2, # Halbachse y
                   angle = 0),
               fill = "gray80", alpha = 0.4) +
  geom_point(size = 3) +
  
  # Kleinere Parteien
  geom_point(data = subset(parties_rating,
                           `Grosse Partei` == "n" &
                             Relevanz_nationale_Abstimmungen != "-"),
             aes(x = eco_x,
                 y = socio_y),
             shape = 21, fill = "grey", color = "black", size = 1, stroke = 1) +
  
  # Labels der kleineren Partein
  geom_text(data = subset(parties_rating,
                          `Grosse Partei` == "n" &
                            Relevanz_nationale_Abstimmungen != "-"),
            aes(x = eco_x,
                y = socio_y,
                label = Partei),
            vjust = -1, fontface = "plain", color = "darkgrey") +
  geom_text(vjust = -0.8) +
  geom_segment(aes(x = 50, xend = 50,
                   y = 0, yend = 100), linetype = "dashed", color = "blue") +
  geom_segment(aes(x = 0, xend = 100,
                   y = 50, yend = 50), linetype = "dashed", color = "blue") +
  annotate("text",
           x = 0,
           y = min(parties_rating$socio_pct_min_y) + 55,
           label = "Links/staatsgläubig", size = 4, hjust = 0.5) +
  annotate("text",
           x = 100,
           y = min(parties_rating$socio_pct_min_y) + 55,
           label = "Rechts/marktwirtschaftlich", size = 4, hjust = 0.5) +
  annotate("text",
           x = 50,
           y = min(parties_rating$socio_pct_min_y) - 3,
           label = "Autoritär/Konservativ", size = 4, hjust = 0.5) +
  annotate("text",
           x = 50,
           y = min(parties_rating$socio_pct_min_y) + 103,
           label = "Libertär/Progressiv", size = 4, hjust = 0.5) +
  scale_x_continuous(limits = c(-10, +110)) +
  labs(x = "Wirtschaftspolitisch",
       y = "Gesellschaftspolitisch",
       title = "Politische Positionierung im Zwei-Achsen-Modell",
       subtitle = "Durchschnitt des Abstimmungsverhaltens als Zentrum, Min-/Max als Ellipse") +
  theme_minimal()+
  theme(plot.title = element_text(size = 18,
                                  margin = margin(b = 30)),
        axis.title.x = element_text(size = 14,
                                    margin = margin(t = 5)),
        axis.title.y = element_text(size = 14,
                                    margin = margin(r = 5))) +
  coord_cartesian(ylim = c(0, 100),
                  xlim = c(0, 100),
                  clip = "off")
```

#### Hauptparteien: Durchschnittswerte als Zentrum und Min/Max als Ellipse / Verbände sowie Klein- und Regionalparteien nur mit ihrem Durchschnittswert

```{r}

ggplot(parties_rating,
       aes(x = eco_pct_avg_x,
           y = socio_pct_avg_y,
           label = Partei)) +
  geom_ellipse(
    aes(x0 = eco_pct_avg_x,
        y0 = socio_pct_avg_y,
        a = (eco_pct_max_x - eco_pct_min_x) / 2, # Halbachse x
        b = (socio_pct_max_y - socio_pct_min_y) / 2, # Halbachse y
        angle = 0),
    fill = "gray80", alpha = 0.4) +
  geom_point(size = 3) +
  
  # Kleinere Parteien
  geom_point(data = subset(parties_rating,
                           `Grosse Partei` == "n" #&
                           #Relevanz_nationale_Abstimmungen != "-"
                           )
                  ,
    aes(x = eco_x, y = socio_y),
    shape = 21, fill = "grey", color = "black", size = 1, stroke = 1
  ) +
  # Labels der kleineren Partein
  geom_text(data = subset(parties_rating,
                          `Grosse Partei` == "n" #&
                          #Relevanz_nationale_Abstimmungen != "-"
                  )
                  ,
    aes(x = eco_x, y = socio_y, label = Partei),
    vjust = -1, fontface = "plain", color = "darkgrey"
  ) +

  geom_text(vjust = -0.8) +
  geom_segment(aes(x = 50, xend = 50,
                   y = 0, yend = 100), linetype = "dashed", color = "blue") +
  geom_segment(aes(x = 0, xend = 100,
                   y = 50, yend = 50), linetype = "dashed", color = "blue") +
  annotate("text",
           x = 0,
           y = min(parties_rating$socio_pct_min_y) + 55,
           label = "Links/staatsgläubig", size = 4, hjust = 0.5) +
  annotate("text",
           x = 100,
           y = min(parties_rating$socio_pct_min_y) + 55,
           label = "Rechts/marktwirtschaftlich", size = 4, hjust = 0.5) +
  annotate("text",
           x = 50,
           y = min(parties_rating$socio_pct_min_y) - 3,
           label = "Autoritär/Konservativ", size = 4, hjust = 0.5) +
  annotate("text",
           x = 50,
           y = min(parties_rating$socio_pct_min_y) + 103,
           label = "Libertär/Progressiv", size = 4, hjust = 0.5) +
  scale_x_continuous(limits = c(-10, +110)) +
  labs(x = "Wirtschaftspolitisch",
       y = "Gesellschaftspolitisch",
       title = "Politische Positionierung im Zwei-Achsen-Modell",
       subtitle = "Grundlage: Durchschnitt des Abstimmungsverhaltens als Zentrum, Min-/Max als Ellipse") +
  theme_minimal()+
  theme(plot.title = element_text(size = 18,
                                  margin = margin(b = 30)),
        axis.title.x = element_text(size = 14,
                                    margin = margin(t = 5)),
        axis.title.y = element_text(size = 14,
                                    margin = margin(r = 5))) +
  coord_cartesian(ylim = c(0, 100),
                  xlim = c(0, 100),
                  clip = "off")
```

### 3D-Koordinatensystem (Testweise)

```{r}
#install.packages("plotly")

library(plotly)

# Datenframe erstellen
parties <- data.frame(
  Partei = c("SP", "SVP", "FDP", "GPS", "GLP", "Mitte", "EVP", "EDU"),
  Wirtschaft = c(20, 85, 80, 30, 60, 60, 40, 90),      # Links = niedrig, Rechts = hoch
  Gesellschaft = c(90, 20, 55, 90, 75, 45, 50, 20),    # Libertär = hoch, Autoritär = niedrig
  Kosmopolitismus = c(90, 15, 60, 95, 85, 50, 55, 20)  # Kosmopolitisch = hoch, Nationalistisch = niedrig
)

# Interaktives 3D-Scatterplot mit Plotly
fig <- plot_ly(
  data = parties,
  x = ~Wirtschaft,
  y = ~Gesellschaft,
  z = ~Kosmopolitismus,
  text = ~Partei,
  type = 'scatter3d',
  mode = 'markers+text',
  marker = list(size = 5),
  textposition = 'top center'
)

# Achsen benennen und Layout anpassen
fig <- fig %>% layout(
  scene = list(
    xaxis = list(title = "Wirtschaftspolitik (links – rechts)"),
    yaxis = list(title = "Gesellschaftspolitik (autoritär – libertär)"),
    zaxis = list(title = "Kosmopolitismus – Nationalismus")
  ),
  title = "Schweizer Parteien im 3D-Koordinatensystem nach Kitschelt"
)

# Plot anzeigen
fig


```
