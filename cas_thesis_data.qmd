---
title: "CAS thesis data"
author: "DaaniiH"
date: 2025-06-01

execute:
  warning: false
format:
  html:
    toc: true
    toc-location: right
    code-fold: true
    code-summary: "Code anzeigen" # Optional, Text für den Aufklapp-Link
    code-tools: true              # Optional, Toolbar für Code-Chunks
    number-sections: true
    max-width: none
editor: visual
editor_options: 
  chunk_output_type: console
number-sections: true
theme: bootstrap
---

# Libraries

```{r}
#| label: load_libraries


library(readr)
library(readxl)
library(pxmake)   # to load PX files
library(pxR)      # to load PX files
library(jsonlite) # to load JSON files

library(purrr)

library(writexl)  # Write Excel files

library(dplyr)
library(tidyr)
library(tidyverse)
library(ggplot2)  # Diagrams
library(ggforce)  # Diagrams
library(plotly)

library(DT)       # datatable()

library(DescTools)
```

# Functions

```{r}
#| label: load_functions


### ### ### ### ### ### ### ### ### ### ### ### ### ### ### ### ### ### ### ###  
# Duplikate in df finden & als $unique oder $duplicates selektionierbar machen
find_and_remove_duplicates <- function(df) {
  list(
    unique = df[!duplicated(df), ],
    duplicates = df[duplicated(df) | duplicated(df, fromLast = TRUE), ]
  )
}


### ### ### ### ### ### ### ### ### ### ### ### ### ### ### ### ### ### ### ###  
# Aktive National- & Ständeräte identifizieren und selektionierbar machen

filter_active <- function(data, von, bis) {
  von <- as.Date(von)
  bis <- as.Date(bis)
  data %>%
    filter(
      DateJoining <= bis,                      # Eintritt vor/am Ende d. Zeitraums
      is.na(DateLeaving) | DateLeaving >= von  # Kein Austritt/nach Beginn des Z..
    )
}

```

# **ETL: Extract, Transform, Load**

-   Daten werden aus verschiedenen Excel-Dateien ausgelesen, unabhängig davon, wie komplex oder verschachtelt sie sind (z. B. mehrere Sheets, verbundene Zellen, unterteilte Datenblöcke).

-   Bei Excel-Dateien mit mehreren Sheets werden Functions angewendet.

-   Header werden identifiziert und ggf. aus mehreren Zeilen zusammengesetzt.

-   Daten werden bereinigt, normalisiert und in das gewünschte Zielformat gebracht (z. B. Wide zu Long, Entfernen von Leerzeilen, Auflösen von verbundenen Zellen, Vereinheitlichung der Spaltenstruktur).

-   Die transformierten Daten werden für die weitere Analyse und Visualisation zu Verfügung gestellt.

## Lookup Tabellen

```{r}
#| label: load_lookups


# Dataframe bilden für Lookup der Kantonsnamen/-Kürzel
lookup_kantone <- data.frame(Kanton = c("Aargau", "Appenzell A. Rh.",
                                        "Appenzell I. Rh.", "Basel-Landschaft",
                                        "Basel-Stadt", "Bern", "Freiburg", "Genf",
                                        "Glarus", "Graubünden", "Jura", "Luzern",
                                        "Neuenburg", "Nidwalden", "Obwalden",
                                        "Schaffhausen", "Schwyz", "Solothurn",
                                        "St. Gallen", "Tessin", "Thurgau", "Uri",
                                        "Waadt", "Wallis", "Zug", "Zürich"),
                             Kt = c("AG", "AR", "AI", "BL", "BS","BE", "FR", "GE",
                                    "GL", "GR", "JU", "LU", "NE","NW", "OW", "SH",
                                    "SZ", "SO", "SG","TI", "TG", "UR", "VD", "VS",
                                    "ZG", "ZH"),
                             stringsAsFactors = FALSE)


#Wahlberechtigte seit 1990
Wahlberechtigte_1990_2024 <- read_excel("data/Wahlberechtigte_1990-2024.xlsx",
                                        sheet = "pivot_as_value") %>% 
  rename(year = Jahr,
         stimmberechtigte_avg_kt = Stimmberechtigte_avg)

# Konsolidierte, bereinigte Lookup-Tabelle einlesen
lookup_parties_consolidated <- read_excel("data/lookup_parties_consolidated.xlsx")

```

## Abstimmungen

```{r}
#| label: load_voting


# Manuell migrierte Lookup Tabellen aus dem PDF-Codebook (swissvotes.ch) laden
# Parteien
lookups_codebook_parties <- read_excel("data/lookup_codebook.xlsx",
                                       sheet = "parties")
# Parteiparolen
lookups_codebook_paroles <- read_excel("data/lookup_codebook.xlsx",
                                       sheet = "paroles")


### ### ### ### ### ### ### ### ### ### ### ### ### ### ### ### ### ### ### ### 


# Ergbenisse der Schweizweite Abstimmungen laden
voting_raw <- read_delim("data/abstimmungen_swissvotes_DATASET CSV 09-02-2025.csv",
                     delim = ";",
                     escape_double = FALSE,
                     trim_ws = TRUE,
                     show_col_types = FALSE)

# Datum formatieren
voting_raw <- voting_raw %>% 
  mutate(datum = dmy(datum))

# Einträge vor 2020 löschen
voting_5y <- voting_raw %>%
  filter(datum >= as.Date("2020-01-01"))

# Abstimmungsdaten der letzten 5 Jahre in Vektor schreiben für spätere Selektion
voting_5y_dates <- voting_5y %>%
  select(datum) %>%
  distinct() %>%
  pull(datum) %>%
  as.character()

# Abstimmungen ab 2020 in datatable() anzeigen
datatable(voting_5y,
          class = 'nowrap',
          filter = 'top',
          options = list(pageLength = 7,
                         scrollX = TRUE,
                         search = list(regex = TRUE,
                                       caseInsensitive = TRUE)))



# Parteien aus Parolen (p- & pdev-..-..) zwecks Lookup/Vereinheitlichung in df schreiben
lookup_voting_parties_label <- bind_rows(
  # Block 1: Staatsebene - Mutterparteien, Verbände & weitere Organisationen
  tibble(party_orig_value = grep("^p-",
                               names(voting_5y),
                               value = TRUE)) %>%
    mutate(level = "state") %>%
    separate(
      party_orig_value,
      into = c("prefix", "short_name", "add_info"),
      sep = "[-_]",
      remove = FALSE,
      extra = "merge",
      fill = "right"),
  # Block 2: Kantonsebene - Jungparteien, Frauensektionen, etc.
  tibble(party_orig_value = grep("^pdev-",
                               names(voting_5y),
                               value = TRUE)) %>%
    mutate(level = "canton_fraction") %>%
    separate(
      party_orig_value,
      into = c("prefix", "short_name", "add_info"),
      sep = "[-_]",
      remove = FALSE,
      extra = "merge",
      fill = "right")) %>%
  # Großschreibung der short_name-Spalte
  mutate(short_name = toupper(short_name),
         long_name = NA_character_,
         source = "Abstimmungen") %>% 
  select(party_orig_value,
         short_name,
         long_name,
         prefix,
         add_info,
         level,
         source)
```

## Wahlen

### Bundesebene

#### Nationalrat

```{r}
#| label: load_nationalrat

# Header laden
header <- as.character(read_excel("data/je-d-17.02.02.02.01.01_BUND_NATIONALRAT.xlsx",
                                  skip = 0,
                                  n_max = 1)[1, ])

# Spaltennamen "Partei 1" zu "Partei" umbenennen
header[header == "Partei 1"] <- "Partei"

# Daten ab Zeile 4 (+25) mit diesem Header einlesen
elec_nationalrat <- read_excel("data/je-d-17.02.02.02.01.01_BUND_NATIONALRAT.xlsx",
                               skip = 3,
                               n_max = 25,
                               col_names = header)

# Refernzen zu Fussnoten aus Parteispalte löschen
elec_nationalrat$Partei <- sub("\\s*\\d+$",
                                   "",
                                   elec_nationalrat$Partei)
```

#### Ständerat

```{r}
#| label: load_ständerat

# Header laden
header <- as.character(read_excel("data/je-d-17.02.03.01_BUND_STÄNDERAT.xlsx",
                                  skip = 0,
                                  n_max = 1)[1, ])

# Daten ab Zeile 5 (+14) mit diesem Header einlesen
elec_ständerat <- read_excel("data/je-d-17.02.03.01_BUND_STÄNDERAT.xlsx",
                              skip = 4,
                              n_max = 14,
                              col_names = header)

# Refernzen zu Fussnoten aus Parteispalte löschen
elec_ständerat$Partei <- sub("\\s*\\d+$",
                                   "",
                                   elec_ständerat$Partei)

```

#### Nationalrat - & Ständerat: Stichtagansatz. Unbrauchbar, Datenqualität ungenügend

```{r}
#| label: load_nationalrat_old
#| eval: false
#| include: false
# 
# #################################################################################
# ## Der Datenexport von parlament.ch ist unvollständig. Es müssten per beliebigem ## Stichtag immer 200 National- und 46 Ständeräte sein, was nicht zutrifft. 
# ## Auserdem befinden sich Duplikate in den Daten.
# ## Es wird deshalb von einer Tagesgenauen Betrachtung abgesehen und stattdessen ## nur die Wahlergebnisse von 2019 und 2023 berücksichtigt.
# ## Zumindest solange, bis Daten korrekt publiziert sind.
# #################################################################################
# 
# # Nationalrat: Daten einlesen
# elec_nationalrat  <- read_excel("data/Ratsmitglieder_1848_DE_BUND_NR.xlsx")
# 
# # Struktur prüfen
# str(elec_nationalrat)
# 
# # Fehlende Werte (NA), Klassen und Levels prüfen
# Abstract(elec_nationalrat)
# PlotMiss(elec_nationalrat)    
#     
# # Duplikate mittels Funktion ermitteln
# elec_nationalrat_duplicates_check <- find_and_remove_duplicates(elec_nationalrat)
#     # elec_nationalrat_duplicates$unique
#     # elec_nationalrat_duplicates$duplicates
# 
# # df mit unique Einträge weiterverwenden 
# elec_nationalrat <- elec_nationalrat_duplicates_check$unique
# 
# # Auf relevante Spalten reduzieren und Datumsformat anpassen
#     # Spaltenüberschriften konkateniert
#     # cat(paste(paste0('"', colnames(elec_nationalrat), '"'),collapse = ",\n"))
# 
# onalrat_final <- elec_nationalrat %>% 
#   select(# "Active",
#          # "FirstName",
#          # "LastName",
#          # "GenderAsString",
#          "CantonName",
#          "CantonAbbreviation",
#          # "CouncilName",
#          # "ParlGroupName",
#          # "ParlGroupAbbreviation",
#          "PartyName",
#          "PartyAbbreviation",
#          # "MaritalStatusText",
#          # "Nationality",
#          # "BirthPlace_City",
#          # "BirthPlace_Canton",
#          # "Mandates",
#          "DateJoining",
#          "DateLeaving",
#          # "Citizenship",
#          # "DateOfBirth",
#          "DateOfDeath") %>%
#   mutate(DateJoining = dmy(DateJoining),
#          DateLeaving = dmy(DateLeaving),
#          DateOfDeath = dmy(DateOfDeath))  
# 
# # Anzeige mit datatable()
# datatable(elec_nationalrat_final,
#           class = 'nowrap',
#           filter = 'top',
#           options = list(pageLength = 7,
#                          scrollX = TRUE,
#                          search = list(regex = TRUE,
#                                        caseInsensitive = TRUE)))
```

```{r}
#| label: load_ständerat_old
#| eval: false
#| include: false
# 
# #################################################################################
# ## Der Datenexport von parlament.ch ist unvollständig. Es müssten per beliebigem ## Stichtag immer 200 National- und 46 Ständeräte sein, was nicht zutrifft. 
# ## Auserdem befinden sich Duplikate in den Daten.
# ## Es wird deshalb von einer Tagesgenauen Betrachtung abgesehen und stattdessen ## nur die Wahlergebnisse von 2019 und 2023 berücksichtigt.
# ## Zumindest solange, bis Daten korrekt publiziert sind.
# #################################################################################
# 
# # Ständerat: Daten einlesen
# elec_ständerat  <- read_excel("data/Ratsmitglieder_1848_DE_BUND_SR.xlsx")
# 
# # Struktur prüfen
# str(elec_ständerat)
# 
# # Fehlende Werte (NA), Klassen und Levels prüfen
# Abstract(elec_ständerat)
# PlotMiss(elec_ständerat)    
#     
# # Duplikate mittels Funktion ermitteln
# elec_ständerat_duplicates_check <- find_and_remove_duplicates(elec_ständerat)
#     # elec_nationalrat_duplicates$unique
#     # elec_nationalrat_duplicates$duplicates
# 
# # df mit unique Einträge weiterverwenden 
# elec_ständerat <- elec_ständerat_duplicates_check$unique
# 
# # Auf relevante Spalten reduzieren und Datumsformat anpassen
#     # Spaltenüberschriften konkateniert
#     # cat(paste(paste0('"', colnames(elec_nationalrat), '"'),collapse = ",\n"))
# 
# elec_ständerat_final <- elec_ständerat %>% 
#   select(# "Active",
#          # "FirstName",
#          # "LastName",
#          # "GenderAsString",
#          "CantonName",
#          "CantonAbbreviation",
#          # "CouncilName",
#          # "ParlGroupName",
#          # "ParlGroupAbbreviation",
#          "PartyName",
#          "PartyAbbreviation",
#          # "MaritalStatusText",
#          # "Nationality",
#          # "BirthPlace_City",
#          # "BirthPlace_Canton",
#          # "Mandates",
#          "DateJoining",
#          "DateLeaving",
#          # "Citizenship",
#          # "DateOfBirth",
#          "DateOfDeath") %>%
#   mutate(DateJoining = dmy(DateJoining),
#          DateLeaving = dmy(DateLeaving),
#          DateOfDeath = dmy(DateOfDeath))
# 
# # Anzeige mit datatable()
# datatable(elec_ständerat_final,
#           class = 'nowrap',
#           filter = 'top',
#           options = list(pageLength = 7,
#                          scrollX = TRUE,
#                          search = list(regex = TRUE,
#                                        caseInsensitive = TRUE)))
```

```{r}
#| label: combine_parliament_old
#| eval: false
#| include: false

# 
# # National- und Ständeratlisten kombinieren
# elec_nr_sr_combined <- bind_rows(
#   elec_nationalrat_final %>% mutate(role = "Nationalrat"),
#   elec_ständerat_final %>% mutate(role = "Ständerat")) %>%
#   select(role, everything())
# 
# 
# # Abstiummungsdatum (voting_5y_dates) als Spalten hinzufügen
# elec_nr_sr_combined <- elec_nr_sr_combined %>%
#   mutate(!!!setNames(rep(list(NA_integer_),
#                          length(voting_5y_dates)),
#                      voting_5y_dates))
# 
# # Ergänzen ob Ratsmitglied zum Zeitpunkt der Abstimmung aktiv war
# elec_nr_sr_combined <- elec_nr_sr_combined %>%
#   mutate(!!!setNames(
#     lapply(voting_5y_dates,
#            function(datum) {
#              abstimmungsdatum <- as.Date(datum)
#              with(., as.integer(                            # 1 der 0 zurück
#                DateJoining <= abstimmungsdatum &
#                  (is.na(DateLeaving) | DateLeaving >= abstimmungsdatum)))}
#            ), voting_5y_dates))
# 
# 
# write_xlsx(elec_nr_sr_combined, "temp_nr_sr.xlsx")
# 
# ### ### ### ### ### ### ### ### ### ### ### ### ### ### ### ### ### ### ### ### 
# 
# 
# # Kanton- und Parteibezeichnungen zwecks Lookup/Vereinheitlichung in df schreiben 
# lookup_elec_nr_sr_combined_canton_label <- elec_nr_sr_combined %>% 
#   select(CantonAbbreviation, CantonName) %>% 
#   distinct()
# 
# 
# lookup_elec_nr_sr_combined_parties_label  <- elec_nr_sr_combined %>%
#   select(PartyAbbreviation, PartyName) %>%
#   distinct() %>%
#   rename(party_orig_value = PartyAbbreviation,
#          long_name = PartyName) %>%
#   mutate(prefix = NA_character_,
#          add_info = NA,
#          level = NA_character_,
#          source = "National_und_Ständerat",
#          short_name = party_orig_value %>%
#            str_replace("-.*", "") %>%         # ab dem ersten "-" abschneiden
#            str_replace("^M-E$", "Mitte") %>%  # "M-E" durch "Mitte" ersetzen
#          toupper())%>% 
#   select(party_orig_value,
#          short_name,
#          long_name,
#          prefix,
#          add_info,
#          level,
#          source)
```

#### National- & Ständerat kombinieren für weitere Bearbeitung

```{r}
#| label: combine_parliament

# Fussnoten aus Spaltenbeschriftungen entfernen
make.unique(colnames(elec_nationalrat))
colnames(elec_nationalrat) <- gsub(" \\d+$",
                                   "",
                                   colnames(elec_nationalrat))
make.unique(colnames(elec_nationalrat))


make.unique(colnames(elec_ständerat))
colnames(elec_ständerat) <- gsub(" \\d+$",
                                 "",
                                 colnames(elec_ständerat))
make.unique(colnames(elec_ständerat))


# df zusammenführen (Wide Format)
elec_nr_sr_combined_wide <- bind_rows(
  elec_nationalrat %>% mutate(role = "Nationalrat"),
  elec_ständerat %>% mutate(role = "Ständerat")) %>%
  select(role, everything())


# df ins Long Format umwandeln
elec_nr_sr_combined_long <- elec_nr_sr_combined_wide %>%
  pivot_longer(cols = matches("^\\d{4}$"),            # Spalten mit 4 Ziffern
               names_to = "election_year",
               values_to = "n_seats") %>%
  mutate(election_year = as.integer(election_year),   # Jahr als Zahl
         n_seats = as.numeric(n_seats))               # Sitze als Zahl oder NA

# Zeitreihe für jede Partei/role vervollständigen und Werte fortschreiben
elec_nr_sr_combined <- elec_nr_sr_combined_long %>%
  rename(party_orig_value = Partei) %>% 
  group_by(role, party_orig_value) %>%
  mutate(year = election_year) %>%                           # Jahrsspalte erzeugen
  complete(year = full_seq(range(election_year, na.rm = TRUE), 1),  # Alle Jahre
           fill = list(n_seats = NA, election_year = NA)) %>%
  arrange(role,
          party_orig_value,
          year) %>%
  fill(election_year,
       n_seats,
       .direction = "down") %>%
  ungroup()
  


# Dataframe analog anderer Staatsebenen in gleiche/ähnliche Struktur bringen
# elec_nr_sr_combined <- elec_nr_sr_combined_long %>%
#   rename(party_orig_value = Partei) %>%
#   group_by(role,
#            party_orig_value) %>%
#   mutate(year = election_year) %>%                            # Jahrsspalte
#   complete(year = full_seq(range(election_year,               # Alle Jahre
#                                  na.rm = TRUE),
#                                  1),                          # 1er Sequenz
#            fill = list(n_seats = NA,
#                        election_year = NA)) %>%
#   arrange(role,                                               # Anordnen vor füllen
#           party_orig_value,
#           year) %>%
#   # Block-Index: zählt, wie oft election_year gefüllt ist / neues Wahljahr beginnt
#   mutate(block = cumsum(!is.na(election_year))) %>%
#   group_by(role,
#            party_orig_value,
#            block) %>%
#   fill(election_year,
#        n_seats,
#        .direction = "down") %>%
#   ungroup() %>%
#   mutate(election_year = as.character(election_year)) %>%
#   select(-block)
#   

elec_nr_sr_combined <- elec_nr_sr_combined_long %>%
  rename(party_orig_value = Partei) %>%
  group_by(role, party_orig_value) %>%
  mutate(election_year = as.integer(election_year),   # temporär numerisch
         year = election_year) %>%
  complete(year = full_seq(range(election_year,       # Range von election_year
                                 na.rm = TRUE),
                           1),                        # 1er Sequenz
           fill = list(n_seats = NA,
                       election_year = NA)) %>%
  arrange(role,
          party_orig_value,
          year) %>%
  mutate(block = cumsum(!is.na(election_year))) %>%
  group_by(role,
           party_orig_value,
           block) %>%
  fill(election_year,
       n_seats,
       .direction = "down") %>%
  ungroup() %>%
  mutate(
    election_year = as.character(election_year),      # zurück als character
    year = as.character(year)) %>%                    # dito
  select(-block)



# Ratssitze pro Jahr (nach-)prüfen
elec_nr_sr_combined_sum_check <- elec_nr_sr_combined %>%
  group_by(year, role) %>%
  summarise(total_n_seats = sum(n_seats,
                                na.rm = TRUE),
    .groups = "drop") %>%
  print(n=Inf)
              
unique(elec_nr_sr_combined$party_orig_value)
```

##### Bund - Parteinamen

```{r}
#| label: tbd

# Partei-Labels identifizieren
lookup_elec_nr_sr_combined_parties_label  <- elec_nr_sr_combined %>%
  select(party_orig_value) %>%
  distinct() %>%
  mutate(party_orig_value = toupper(party_orig_value),
         short_name = party_orig_value,
         short_name = if_else(short_name == "DIE MITTE",      # Umbenennen
                              "MITTE",
                              short_name),
         short_name = if_else(short_name == "MCG (MCR)",      # Umbenennen
                              "MCG",
                              short_name),
         short_name = gsub("\\.", "", short_name),            # . entfernen
         long_name = NA_character_,
         prefix = NA_character_,
         add_info = NA,
         level = NA_character_,
         source = "National_und_Ständerat") %>%
  select(party_orig_value,
         short_name,
         long_name,
         prefix,
         add_info,
         level,
         source) %>% print(n=Inf)
```

### Kantonsebene

#### Kantonale Regierung (Exekutive)

Die Kantonalen Abstimmungen finden nicht in allen kantonen gleichzeitg statt. Deshalb genauer die Räte/Konstellation zum Zeitpunkt der jeweiligen Abstimmung zu prüfen.

Die Struktur der "schön formatierten" Exceldatei lässt keinen "simplen" Import zu.

-   1 Excelsheet / Jahr

-   Header ist in Zeile 2 und nicht vollständig

-   Daten (für Kantone) starten in Zeile 4 aber enden auf Zeile 29 bevor es mit Kommentaren und Fussnoten weitergeht.

##### Dateipfad und gewünschte Sheets festlegen

```{r}
#| label: set_path_Kanton

dateipfad <- "data/je-d-17.02.06.01_KANTON_Kantonale_Regierungswahlen.xlsx"  

selected_sheets <- c("2024", "2023", "2022","2021","2020","2019")
```

##### Function

```{r}
#| label: load_function


import_election_data <- function(dateipfad, sheetname) {
  
  # Headerzeilen einlesen  
  header <- readxl::read_excel(dateipfad,
                               sheet = sheetname,
                               skip = 1,
                               n_max = 0) %>%
    names()
  
  # Header anpassen: Wahljahr vereinheitlichen und Kanton hinzufügen
  header[grepl("^Wahljahr", header)] <- "Wahljahr" 
  header <- c("Kanton", header)
        
  # Daten ab Zeile 4 importieren
  daten_raw <- read_excel(dateipfad,
                          sheet = sheetname,
                          skip = 3,
                          col_names = header)
  
  # Zeilen ohne "Wahljahr" ausschliessen
  wahljahr_col <- names(daten_raw)[grepl("^Wahljahr",
                                         names(daten_raw))][1]
  names(daten_raw)[names(daten_raw) == wahljahr_col] <- "Wahljahr"

  daten_wide <- daten_raw %>%
    filter(!is.na(suppressWarnings(as.numeric(.data[[wahljahr_col]]))))
  
  # Zu pivotierenden Spalten in numeric umwandeln
  cols_pivot <- setdiff(names(daten_wide),
                        c("Kanton", wahljahr_col))
  daten_wide <- daten_wide %>%
    mutate(across(all_of(cols_pivot),
                  as.numeric))
    
  # 6. Pivotieren
  daten_long <- daten_wide %>%
    pivot_longer(
      cols = all_of(cols_pivot),
      names_to = "Partei",
      values_to = "Wert")
  
  return(daten_long)
}
```

##### Function ausführen: Import und Konsolidation

```{r}
#| label: run_function

# Objekt erstellen, mit Sheets als tibble/dataframe
daten_liste <- setNames(lapply(selected_sheets,
                               function(sheet) import_election_data (dateipfad,
                                                                     sheet)),
                        selected_sheets)

str(daten_liste)
# lapply(daten_liste, summary)

# Alle tibbles zu einem Dataframe zusammenfügen
elec_kantonale_regierung_combined <- bind_rows(daten_liste,
                                               .id = "year") %>%
  rename(election_year = Wahljahr,
         party_orig_value = Partei,
         n_seats = Wert) %>%
  mutate(role = "Kantonsregierung",
         
         election_year = as.character(election_year)
         
         
         ) %>% 
  filter(party_orig_value != "Total") %>%
  left_join(lookup_kantone, by = "Kanton") %>%
  select(role,
         party_orig_value,
         year,
         election_year,
         n_seats,
         Kt,
         Kanton,
         everything())

# Ratssitze pro Jahr (nach-)prüfen
elec_kantonale_regierung_sum_check <- elec_kantonale_regierung_combined %>%
  group_by(year, role) %>%
  summarise(total_n_seats = sum(n_seats,
                                na.rm = TRUE),
    .groups = "drop") %>%
  print(n=Inf)

 
datatable(elec_kantonale_regierung_combined,
          class = 'nowrap',
          filter = 'top',
          options = list(pageLength = 7,
                         scrollX = TRUE,
                         search = list(regex = TRUE,
                                       caseInsensitive = TRUE)))
```

##### Kanton - Parteinamen

```{r}
#| label: tbd

# Parteinamenvarianten
unique(elec_kantonale_regierung_combined$party_orig_value)

# Parteien zwecks Lookup/Vereinheitlichung in df schreiben
lookup_kantonale_regierung_parties_label <- elec_kantonale_regierung_combined %>%
  mutate(level = NA_character_,
         long_name = NA_character_,
         source = "Kantonale_Regierung",
         
         add_info = str_extract(party_orig_value,
                                "\\d+(?=\\)?$)"),  # Zahl am Ende/vor Klammer-Ende
         short_name = str_remove(party_orig_value,
                                 "\\s*\\d+\\)?$"), # - Leerzeichen/Zahl/Klammer
         prefix = NA_character_) %>%
  select(party_orig_value,
         short_name,
         long_name,
         prefix,
         add_info,
         level,
         source) %>%
  # Großschreibung der short_name-Spalte
  mutate(short_name = toupper(short_name)) 
 
# Output prüfen (unique/distinct)
lookup_kantonale_regierung_parties_label %>% distinct() %>% print(n = Inf)
```

### Gemeindeebene

#### Exekutiven der statistischen Städte

-   1 Excelsheet / Jahr

-   Header zweizeilig mit Start in Zeile –\> 3 `skip = 2, n_max = 2,`

-   Teils verbundene Header-Zeilen (vertikal/horizontal)

-   Cluster Einwohnerzahlen unterteilt Daten

-   Parteinamen uneinheitlich aufgrund von Fussnoten

--\> Datenformat "wide" zuerst bereinigen und ins "long" Format bringen

##### Dateipfad und gewünschte Sheets festlegen

```{r}
#| label: set_path_Gemeinde

dateipfad <- "data/je-d-17.02.07.01_GEMEINDE_Die Exekutiven der statistischen Städte.xlsx"

selected_sheets <- c("2024", "2023", "2022","2021","2020","2019") 
```

##### Function für den Import der Gemeindedaten

```{r}
#| label: load_function_Gemeinde

importiere_sheet <- function(dateipfad, sheetname) {

      ###################################################################
      ########## DATEN IMPORTIEREN ######################################
      ########## Header definieren ######################################
      ###################################################################
      
      
      # Headerzeilen einlesen
      header <- suppressMessages(read_excel(dateipfad,
                   sheet = sheetname,
                   skip = 2,
                   n_max = 2,
                   col_names = FALSE))
      
      # Daten  einlesen
      daten_raw <- suppressMessages(read_excel(dateipfad,
                              sheet = sheetname,
                              skip = 5,
                              col_names = FALSE))
      
      
      # Die Spaltennamen zusammensetzen
      # Leere Zellen in 1. Headerzeile mit Werten von rechts auffüllen wenn leer/NA
      header_filled <- as.data.frame(t(header))   # t() "matrix transpose"
      header_filled <- fill(header_filled,        
                            V1,                   # Header Spalte 1 (V1) auffüllen
                            .direction = "down")  # Werte nach unten übernehmen
      header_filled <- t(header_filled)           # t() nochmals (zurück)
      
      # Spaltennamen kombinieren
      spaltennamen <- paste(header_filled[1, ],
                            header_filled[2, ],
                            sep = "_")
      spaltennamen <- gsub("_NA|NA_","", spaltennamen) # Entfernt überflüssige NAs
      
      # Spaltennamen zuweisen
      colnames(daten_raw) <- spaltennamen
      
      
      ###################################################################
      ########## TRANSPONIEREN ##########################################
      ########## Gemeindegrössen Cluster ################################
      ###################################################################
      
      
      # Cluster Einwohnerzahl als Spalte verwenden
      daten_wide <- daten_raw %>%
        mutate(Gemeindegrösse_Cluster =             # Name der neuen Spalte
                 ifelse(
                   is.na(                           # 4) auf NA prüfen
                     suppressWarnings(        # 3) Warnung aus (z.B. "≥ ..Einw..")
                     as.numeric(                    # 2) Wert als Zahl 
                     gsub("'", "", `Kantons-Nr.`)   # 1) Tausender Zeichen (')                                                              entfernen
                   ))),
                   as.character(`Kantons-Nr.`),     # 5) Wert von "Kantons-Nr" 
                   NA_character_                    #    sonst NA   
                 ))  %>%
        fill(Gemeindegrösse_Cluster,
             .direction = "down") %>%              # Cluster nach unten auffüllen
        filter(!is.na(suppressWarnings(
          as.numeric(gsub("'", "", `Kantons-Nr.`))))) # Herausfiltern von Zeilen                                                           mit NICHT-numerischem Wert
    
    
    # Ansicht (Snapshot) nach transponieren
    daten_wide[1:10,                    # 10 Zeilen
               c(1:10,                  # 10 Spalten +
                 ncol(daten_wide))]     # Letzte Spalte
                                        # ncol() von df daten_wide --> Anz. Spalten
                                        # Anzahl Spalten = Position letzte Spalte
    
    
    
    ###################################################################
    ########## TRANSPONIEREN ##########################################
    ########## Frauen, Männer, Total & Parteien ## ####################
    ###################################################################
    
    
    
    daten_long <- daten_wide %>%
      mutate(across(matches("(_Frauen|_Männer|_Total)$"),
                    ~ suppressWarnings(as.numeric(.)))) %>%       # Werte numerisch
      pivot_longer(cols = matches("(_Frauen|_Männer|_Total)$"),   # Spaltenauswahl
                   names_to = c("party_orig_value", "m_w_Total"),  # Label-Spalte
                   names_pattern = "^(.*)_(Frauen|Männer|Total)$",# RegEx
                   values_to = "Wert")                            # Wert-Spalte
    
    return(daten_long)

}
```

##### Function ausführen: Import der Dateien testen

```{r}
#| label: run_test_function_Gemeinde


for (sheet in selected_sheets) {
  cat("\n-----------------------------\n")
  cat("Versuche Sheet:", sheet, "\n")
  result <- tryCatch({
    dat <- importiere_sheet(dateipfad, sheet)
    cat("Sheet erfolgreich eingelesen:", sheet, "\n")
    # Zusammenfassung:
    cat("Anzahl Zeilen:", nrow(dat), "\n")
    cat("Anzahl Spalten:", ncol(dat), "\n")
    cat("Spaltennamen (erste 15):", paste(names(dat)[1:min(15, ncol(dat))], collapse = ", "), "\n")
    TRUE
  }, error = function(e) {
    cat("Fehler beim Einlesen von Sheet:", sheet, "\n")
    cat("Fehlermeldung:", e$message, "\n")
    FALSE
  })
}
```

##### Function ausführen: Import und Konsolidation

```{r}
#| label: run_function_Gemeinde

# Objekt erstellen, mit Sheets als tibble/dataframe
daten_liste <- setNames(lapply(selected_sheets,
                               function(sheet) importiere_sheet(dateipfad, sheet)),
                        selected_sheets)

str(daten_liste)
# lapply(daten_liste, summary)


# Alle tibbles zu einem Dataframe zusammenfügen
elec_gemeinde_exekutiven_combined <- bind_rows(daten_liste,
                                            .id = "year") %>% 
  filter(m_w_Total == "Total",
         party_orig_value != "Total") %>% 
  rename(election_year = Wahljahr,
         n_seats = Wert,
         Kt = Kanton) %>% 
  mutate(role = "Gemeindeexekutive",
         election_year = as.character(election_year)) %>%
  select(-c('Grössenklasse-Nr.',
            Grössenklasse,
            `Kantons-Nr.`,
            m_w_Total)) %>%
  left_join(lookup_kantone, by = "Kt") %>%
  select(role,
         party_orig_value,
         year,
         election_year,
         n_seats,
         Kt,
         Kanton,
         everything())
  
# Ratssitze pro Jahr (nach-)prüfen
elec_gemeinde_exekutiven_sum_check <- elec_gemeinde_exekutiven_combined %>%
  group_by(year) %>%                         # Gruppieren nach Jahr
  summarise(summe = sum(n_seats, na.rm = TRUE)) # Summe berechnen, NAs ignorieren





# TODO Grosses Datatable, deshalb auskommentieren oder ander Lösung..
# datatable(elec_gemeinde_exekutiven_combined,
#           class = 'nowrap',
#           filter = 'top',
#           options = list(pageLength = 7,
#                          scrollX = TRUE,
#                          search = list(regex = TRUE,
#                                        caseInsensitive = TRUE)))


# Parteinamenvarianten
unique(elec_gemeinde_exekutiven_combined$party_orig_value)

# Parteien zwecks Lookup/Vereinheitlichung in df schreiben
lookup_gemeinde_exekutiven_parties_label <- elec_gemeinde_exekutiven_combined %>%
  mutate(add_info = str_extract(party_orig_value,
                                "\\d+(?=\\)?$)"),  # Zahl am Ende/vor Klammer-Ende
         short_name = str_remove(party_orig_value,
                                 "\\s*\\d+\\)?$"), # - Leerzeichen/Zahl/Klammer
         long_name = NA_character_, 
         prefix = NA_character_,
         level = NA_character_,
         source = "Gemeinde_Exekutiven") %>% 
  # Großschreibung der short_name-Spalte
  mutate(short_name = toupper(short_name))%>% 
  select(party_orig_value,
         short_name,
         long_name,
         prefix,
         add_info,
         level,
         source)
  



# Output prüfen (unique/distinct)
lookup_gemeinde_exekutiven_parties_label %>% distinct() %>% print(n = Inf)


```

## Parteilandschaft

```{r}
#| label: load_parties_rating

parties_rating <- read_excel("data/parties_economic_socio-political_rating.xlsx",
                             sheet = "matrix_eco-socio_enhanced")
```

## Lookup tables

### Parteinamen

Die verschiedenen Quellen verwenden teils unteschiedliche Parteibezeichnungen. Zur Vereinheitlichung wird deshalb initial eine Lookup Tabelle gebildet.

```{r}
#| label: load_parties

# National- und Ständerat
print(lookup_elec_nr_sr_combined_parties_label %>%
        distinct(),
      n = 3)

# Kantonale Regierung
print(lookup_kantonale_regierung_parties_label %>%
        distinct(),
      n = 3)

# Gemeinde Exekutiven
print(lookup_gemeinde_exekutiven_parties_label %>%
        distinct(),
      n = 3)

# Abstimmungen
print(lookup_voting_parties_label %>%
        distinct(),
      n = 3)


# Alle Dataframes zu einem zusammenführen, Duplikate entfernen und Master joinen
lookup_all_parties <- bind_rows(
  lookup_elec_nr_sr_combined_parties_label,
  lookup_kantonale_regierung_parties_label,
  lookup_gemeinde_exekutiven_parties_label,
  lookup_voting_parties_label)%>%
  distinct() %>% 
  left_join(lookups_codebook_parties %>%
              select(short_name,
                     Partei,
                     Parteiname),
            by = "short_name") %>%
  select(Partei,
         Parteiname,
         everything())

write_xlsx(lookup_all_parties, "lookup_all.xlsx")
```

# Transformation & visualization

## Abstimmungen

```{r}
#| label: tbd

# Relevante Felder selektionieren
voting_5y_reduced_fields <- voting_5y %>%
  select(anr,
         datum,
         titel_kurz_d,
         titel_off_d,
         rechtsform, #1 Obligatorisches Referendum
                     #2 Fakultatives Referendum
                     #3 Volksinitiative
                     #4 Direkter Gegenentwurf zu einer Volksinitiative
                     #5 Stichfrage
         dep,
         `br-pos`,   
                     #1 Befürwortend
                     #2 Ablehnend
                     #3 Keine
                     #8 Vorzug für den Gegenentwurf (bei Stichfragen)
                     #9 Vorzug für die Volksinitiative (bei Stichfragen)
                     #. Missing
         legisjahr,
         `pa-iv`,
         `bv-pos`,   
                     #1 Befürwortend
                     #2 Ablehnend
                     #3 Keine Abstimmungsempfehlung des Parlaments
                     #8 Vorzug für den Gegenentwurf (bei Stichfragen)
         `nr-pos`,   
                     #1 Befürwortende Mehrheit im Nationalrat
                     #2 Ablehnende Mehrheit im Nationalrat
                     #3 Keine Abstimmungsempfehlung des Nationalrats
                     #8 Vorzug für den Gegenentwurf (bei Stichfragen)
         nrja,
         nrnein,
         `sr-pos`,   
                     #1 Befürwortende Mehrheit im Ständerat
                     #2 Ablehnende Mehrheit im Ständerat
                     #3 Keine Abstimmungsempfehlung des Ständerats
                     #8 Vorzug für den Gegenentwurf (bei Stichfragen)
         srja,
         srnein,
         # Parteiparolen
         starts_with("p-"),
                     #1 Ja-Parole
                     #2 Nein-Parole
                     #3 keine Parole abzugeben
                     #4 empfahl, einen leeren Stimmzettel einzulegen
                     #5 Stimmfreigabe
                     #8 Bevorzugung des Gegenentwurfs (bei Stichfrage)
                     #9 Bevorzugung der Volksinitiative (bei Stichfrage)
                     #66 Neutral: keine Parole oder Empfehlung auf leer einlegen                        #9999 Organisation existiert nicht
                     #. Unbekannt
         # Parteiparolen Kanton / Parteisektion
         starts_with("pdev-"),
                     #1 Ja-Parole
                     #2 Nein-Parole
                     #3 keine Parole abzugeben
                     #4 empfahl, einen leeren Stimmzettel einzulegen
                     #5 Stimmfreigabe
                     #8 Bevorzugung des Gegenentwurfs (bei Stichfrage)
                     #9 Bevorzugung der Volksinitiative (bei Stichfrage)
                     # [leer] Parole gleich wie Mutterpartei (oder unbekannt)         
         volk,       #0 Eine Mehrheit der Abstimmenden hat die Vorlage abgelehnt
                     #1 Eine Mehrheit der Abstimmenden hat die Vorlage angenommen
                     #8 Bei Stichfragen:  Mehrheit für Gegenentwurfs
                     #9 Bei Stichfragen:  Mehrheit Volksinitiative
         stand,
                     #0 Die Vorlage hat keine Mehrheit der Standesstimmen er-reicht
                     #1 Die Vorlage hat die Mehrheit der Standesstimmen erreicht
                     #3 Ständemehr nicht notwendig
                     #8 Bei Stichfragen: Mehrheit für Gegenentwurf
                     #9 Bei Stichfragen: Mehrheit für Volksinitiative
         annahme,    #0 Ablehnung der Vorlage
                     #1 Annahme der Vorlage
                     #8 Bei Stichfragen: Gegenentwurf angenommen
                     #9 Bei Stichfragen: Volksinitiative angenommen
                     #. Bei Stichfragen: Ergebnis der Stichfrage obsolet
         berecht,
         stimmen,
         bet,
         leer,
         ungultig,
         gultig,
         volkja,
         volknein,
         `volkja-proz`)

```

```{r}
#| label: tbd

# Spaltennamen extrahieren, die ins Long Format sollen
sel_cols <- names(voting_5y_reduced_fields)[
  grepl("^p-|^pdev-|(-pos)",
        names(voting_5y_reduced_fields))
]

# Spalteninhalte als Charakter definieren
voting_5y_reduced_fields[sel_cols] <- lapply(voting_5y_reduced_fields[sel_cols],
                                             as.character)

# Wide in Long Format
voting_long <- voting_5y_reduced_fields %>%  pivot_longer(cols = all_of(sel_cols),
                                                          names_to = "variable",
                                                          values_to = "value")

# Lookup für p- und pdev-
lookup_parole <- read.table(text = '1\tparole_Ja
                                    2\tparole_Nein
                                    3\tparole_keine
                                    4\tparole_Enthalten
                                    5\tparole_keine
                                    8\tparole_Gegenentwurf (Stichfrage))
                                    9\tparole_Volksinitiative (Stichfrage)
                                    66\tparole_keine
                                    .\tparole_keine
                                    9999\tparole_keine
                                    \tparole_keine',
                            sep = "\t",
                            col.names = c("wert",
                                          "label"),
                            stringsAsFactors = FALSE,
                            fill = TRUE,
                            quote = "")


# Lookup für -pos
lookup_pos <- read.table(text = '.\tpos_Missing
                                  1\tpos_Befürwortend
                                  2\tpos_Ablehnend
                                  3\tpos_Keine
                                  8\tpos_Vorzug Gegenentwurf (bei Stichfragen)
                                  9\tpos_Vorzug Volksinitiative (bei Stichfragen)',
                         sep = "\t",
                         col.names = c("wert",
                                       "label"),
                         stringsAsFactors = FALSE,
                         fill = TRUE,
                         quote = "")
lookup_pos$wert <- as.character(trimws(lookup_pos$wert))

# 2. Lookup anwenden (Join)

# value als Character
lookup_parole$wert <- as.character(trimws(lookup_parole$wert))
lookup_pos$wert <- as.character(trimws(lookup_pos$wert))
voting_long$value <- as.character(trimws(voting_long$value))

# Join je nach variable-Typ
voting_long <- voting_long %>%
  mutate(value = trimws(value))  %>%
  mutate(lookup_type = case_when(grepl("^p-|^pdev-",
                                       variable) ~ "parole",
                                 grepl("-pos",
                                       variable) ~ "pos",
                                 TRUE ~ NA_character_)) %>%
  left_join(lookup_parole %>%
              rename(label_parole = label),
            by = c("value" = "wert"),
            na_matches = "never") %>%
  left_join(lookup_pos %>%
              rename(label_pos = label),
            by = c("value" = "wert"),
            na_matches = "never") %>%
  mutate(label = case_when(lookup_type == "parole" ~ label_parole,
                           lookup_type == "pos" ~ label_pos,
                           TRUE ~ NA_character_)) %>% 
  select(-label_parole,
         -label_pos,
         -lookup_type)



# NA korrigeren
voting_long <- voting_long %>%
  mutate(
    label = case_when(
      is.na(label) & grepl("^p-|^pdev-", variable) ~ "parole_keine",
      is.na(label) & grepl("-pos", variable)       ~ "pos_keine",
      TRUE                                         ~ label
    )
  )


# 3. One-Hot-Encoding (Dummy-Codierung)
voting_long$dummy <- 1L

# Pivotieren: Jede label-Ausprägung wird eigene Spalte, 1 falls zutreffend, sonst 0
voting_wide <- voting_long %>%
  pivot_wider(
    id_cols = setdiff(names(voting_long), c("value", "label", "dummy")),
    names_from = label,
    values_from = dummy,
    values_fill = 0
  )

voting_5y_long <- voting_wide
```

```{r}
#| label: tbd

str(voting_5y_long)

tmp_voting_5y_long <- voting_5y_long %>%
  left_join(lookup_all_parties %>% select(party_orig_value,
                                          Partei),
            by = c("variable" = "party_orig_value")) %>% 
   relocate(Partei, .after = variable)

voting_5y_long <- tmp_voting_5y_long
rm(tmp_voting_5y_long)

#Desc(voting_5y_long)
colnames(voting_5y_long)

```

```{r}

voting_5y_plot_data <- voting_5y %>% 
  select(datum,
         titel_kurz_d,
         rechtsform,
         annahme)

split_list <- voting_5y_plot_data %>%
  group_by(rechtsform) %>%
  group_split()      

voting_obli_referendum <- split_list[[1]]
voting_faku_referendum <- split_list[[2]]
voting_volksinitiative <- split_list[[3]]

# Heatmap erstellen
plot_data <- voting_5y_plot_data %>%
  mutate(annahme = factor(annahme, levels = c("0", "1"), labels = c("Nein", "Ja")))

# Heatmap
ggplot(plot_data,
       aes(x = annahme,
           y = titel_kurz_d,
           fill = annahme)) +
  geom_tile(color = "white") +
  scale_fill_manual(values = c("Nein" = "red", "Ja" = "green")) +
  labs(
    title = "Heatmap der Abstimmungsergebnisse",
    x = "Ergebnis",
    y = "Vorlage",
    fill = "Annahme"
  ) +
  theme_minimal() +
  theme(axis.text.y = element_text(size = 8))





plot_data <- voting_5y_plot_data %>%
  mutate(annahme = factor(annahme, levels = c("0","1"), labels = c("Nein", "Ja")))

levels(plot_data$annahme)

ggplot(plot_data,
       aes(x = annahme,
           y = titel_kurz_d,
           fill = annahme)) +
  geom_tile(color = "white") +
  scale_fill_manual(values = c("Nein" = "red", "Ja" = "green")) +
  labs(
    title = "Heatmap der Abstimmungsergebnisse",
    x = "Ergebnis",
    y = "Vorlage",
    fill = "Annahme"
  ) +
  theme_minimal() +
  theme(axis.text.y = element_text(size = 8)) +
  facet_wrap(~ rechtsform, scales = "free_y")


```

## Wahlen: Parteistärken per Abstimmungstag je Staatsebene

### Dataframes kombinieren, Parteinamen vereinheitlichen, alte df löschen

```{r}
#| label: tbd

# Vereinheitlichte Dataframes (Exekutiven je Staatsebene) konsolidieren
elec_all_combined <- bind_rows(
  elec_nr_sr_combined,
  elec_kantonale_regierung_combined,
  elec_gemeinde_exekutiven_combined)

# Lookup für einheiltiche Parteinamen anwenden
elec_all_combined <- elec_all_combined %>%
  left_join(
    lookup_parties_consolidated %>% select(Partei, Parteiname, party_orig_value),
    by = "party_orig_value",
    relationship = "many-to-many"
  ) %>%
  relocate(Partei, Parteiname, .after = party_orig_value)

# # Clean-up: Nacht der Kombinierung nicht mehr benötigte "election" Tabellen löschen
# rm(list = ls(pattern = "^elec_")[       # Objekte die mit elec_ starten aber nicht
#   !grepl("(_all_combined|_all_final)$", # auf all_combined oder all_final enden
#          ls(pattern = "^elec_"))])
```

### Parteistärken

#### Anzahl Sitze & Prozentualer Anteil

##### Jahre eingrenzen

```{r}
#| label: tbd

# Jahre eingrenzen
elec_all_combined_input <-  elec_all_combined %>% 
  filter(year >= "2019")
```

##### Staatsebene: National- und Ständerat

```{r}
#| label: tbd

#################################################################################
# Staatsebene
elec_nr_sr_lvl_state <- elec_all_combined_input %>%
  filter(role %in% c("Ständerat",
                     "Nationalrat")) %>%
  group_by(year,
           Partei) %>%
  summarise(n_seats_sum = sum(n_seats,
                              na.rm = TRUE),
            .groups = "drop") %>%
  group_by(year) %>%
  mutate(n_seats_pct = 100 * n_seats_sum / sum(n_seats_sum, na.rm = TRUE)) %>%
  ungroup() %>%
  filter(n_seats_sum > 0)
```

##### Kantonsebene: Gewichtung nach Stimmberechtigten je Kanton für Aggregation auf Staatslevel

```{r}
#| label: tbd

#################################################################################
# Kantonsebene
# aggregiert auf Kantonsebene
elec_kanton_lvl_kt <- elec_all_combined_input %>%
  filter(role == "Kantonsregierung") %>%
  group_by(year,
           Kt,
           Partei) %>%
  summarise(n_seats_sum = sum(n_seats,
                              na.rm = TRUE),
            .groups = "drop") %>%
  group_by(year,
           Kt) %>%
  mutate(n_seats_pct = 100 * n_seats_sum / sum(n_seats_sum,
                                               na.rm = TRUE)) %>%
  ungroup() %>% print(n=30)


# aggregiert auf Staatsebene
elec_kanton_lvl_state <- elec_all_combined_input %>%
  filter(role == "Kantonsregierung") %>%
  left_join(Wahlberechtigte_1990_2024 %>%
              group_by(year) %>% 
              summarise(stimmberechtigte_avg_state = sum(stimmberechtigte_avg_kt,
                                                         na.rm = TRUE)),
    by = "year") %>%
  mutate(n_seats_weighted = n_seats * stimmberechtigte_avg_state) %>%
  group_by(year,
           Partei) %>%
  summarise(n_seats_sum = sum(n_seats,
                              na.rm = TRUE),
            n_seats_sum_weighted = sum(n_seats_weighted,
                                       na.rm = TRUE),
            stimmberechtigte_avg_state = first(stimmberechtigte_avg_state),
            .groups = "drop") %>%
  group_by(year) %>%
  mutate(n_seats_pct =
           100 * n_seats_sum / sum(n_seats_sum,
                                   na.rm = TRUE),
         n_seats_pct_weighted =
           100 * n_seats_sum_weighted / sum(n_seats_sum_weighted,
                                            na.rm = TRUE)) %>%
  ungroup()
```

##### Gemeindeebene: Gewichtung nach Einwohner je Gemeinde aggregiert auf Kanton und Staat

```{r}
#| label: tbd

# aggregiert auf Gemeindeebene
elec_gemeinde_lvl_gemeinde  <- elec_all_combined_input %>%
  filter(role == "Gemeindeexekutive",
         n_seats != 0) %>%
  group_by(year,
           Gemeinde,
           Partei) %>%
  summarise(n_seats_sum = sum(n_seats,
                              na.rm = TRUE),
            .groups = "drop") %>%
  group_by(year,
           Gemeinde) %>%
  mutate(n_seats_pct = 100* n_seats_sum / sum(n_seats_sum,
                                         na.rm = TRUE)) %>%
  ungroup()

# aggregiert auf Kantonsebene
elec_gemeinde_lvl_kt <- elec_all_combined_input %>%
  filter(role == "Gemeindeexekutive",
         n_seats != 0) %>%
  group_by(year,
           Kt,
           Gemeinde,
           Partei) %>%
  summarise(n_seats_sum = sum(n_seats, na.rm = TRUE),
            Einwohner = first(Einwohner),
            .groups = "drop") %>%
  mutate(weighted_seats = n_seats_sum * Einwohner) %>%
  group_by(year,
           Kt,
           Partei) %>%
  summarise(n_seats_sum = sum(n_seats_sum,                  # ungewichtete Sitze
                              na.rm = TRUE),
            n_seats_sum_weighted = sum(weighted_seats,      # gewichtete Sitze
                                     na.rm = TRUE), 
            .groups = "drop") %>%
  group_by(year,
           Kt) %>%
  mutate(n_seats_pct = 100 *                                # ungewichtet %
           n_seats_sum / sum(n_seats_sum,
                             na.rm = TRUE),
         n_seats_pct_weighted = 100 *                       # gewichtet %  
           n_seats_sum_weighted / sum(n_seats_sum_weighted,
                                    na.rm = TRUE)) %>%
  ungroup()

# aggregiert auf Staatsebene 
elec_gemeinde_lvl_state <- elec_all_combined_input %>%
  filter(role == "Gemeindeexekutive",
         n_seats != 0) %>%
  group_by(year,
           Gemeinde,
           Partei) %>%
  summarise(n_seats_sum = sum(n_seats,
                              na.rm = TRUE),
            Einwohner = first(Einwohner),
            .groups = "drop") %>%
  mutate(weighted_seats = n_seats_sum * Einwohner) %>%
  group_by(year,
           Partei) %>%
  summarise(n_seats_sum = sum(n_seats_sum,                   # ungewichtete Sitze
                              na.rm = TRUE),
            n_seats_sum_weighted = sum(weighted_seats,       # gewichtete Sitze
                                       na.rm = TRUE),
            .groups = "drop") %>%
  group_by(year) %>%
  mutate(n_seats_pct = 100 *
           n_seats_sum / sum(n_seats_sum,
                             na.rm = TRUE),                  # ungewichtet %
         n_seats_pct_weighted = 100 *
           n_seats_sum_weighted / sum(n_seats_sum_weighted,
                                      na.rm = TRUE)) %>%     # gewichtet %
  ungroup()
```

### Entwicklung über die Jahre

elec_gemeinde_lvl_gemeinde

elec_gemeinde_lvl_kt

elec_gemeinde_lvl_state

elec_kanton_lvl_kt

elec_kanton_lvl_state

elec_nr_sr_lvl_state

### Übersicht aller elec\_ dataframes

```{r}
#| label: tbd


elec_gemeinde_lvl_gemeinde
elec_gemeinde_lvl_kt
elec_gemeinde_lvl_state
elec_kanton_lvl_kt
elec_kanton_lvl_state
elec_nr_sr_lvl_state


parties_rating

elec_nr_sr_lvl_state

# Liste der Dataframes
df_names <- c(
  "elec_gemeinde_lvl_gemeinde",
  "elec_gemeinde_lvl_kt",
  "elec_gemeinde_lvl_state",
  "elec_kanton_lvl_kt",
  "elec_kanton_lvl_state",
  "elec_nr_sr_lvl_state"
)

df_overview <- function(df_name) {
  df <- get(df_name)
  cat("====", df_name, "====\n")
  cat("Anzahl Zeilen:", nrow(df), "\n")
  cat("Anzahl Spalten:", ncol(df), "\n")
  cat("Spaltennamen:\n")
  print(names(df))
  
  # Dynamische Sortierung: Nur vorhandene Spalten werden verwendet
  sort_cols <- c()
  sort_orders <- c()
  
  # 1) year (aufsteigend)
  if ("year" %in% names(df)) {
    df$year <- as.numeric(df$year)
    sort_cols <- c(sort_cols, "year")
    sort_orders <- c(sort_orders, TRUE) # TRUE = aufsteigend
  }
  # 2) Gemeinde (alphabetisch)
  if ("Gemeinde" %in% names(df)) {
    sort_cols <- c(sort_cols, "Gemeinde")
    sort_orders <- c(sort_orders, TRUE)
  }
  # 3) Kt (alphabetisch)
  if ("Kt" %in% names(df)) {
    sort_cols <- c(sort_cols, "Kt")
    sort_orders <- c(sort_orders, TRUE)
  }
  # 4) n_seats_sum (absteigend)
  if ("n_seats_sum" %in% names(df)) {
    df$n_seats_sum <- as.numeric(df$n_seats_sum)
    sort_cols <- c(sort_cols, "n_seats_sum")
    sort_orders <- c(sort_orders, FALSE) # FALSE = absteigend
  }
  
  # Sortiere Dataframe, falls mindestens eine Sortierspalte vorhanden ist
  if (length(sort_cols) > 0) {
    # Erzeuge eine Liste von Spalten für do.call(order, ...)
    order_args <- lapply(seq_along(sort_cols), function(i) {
      col <- df[[sort_cols[i]]]
      if (!sort_orders[i]) -col else col
    })
    df <- df[do.call(order, order_args), ]
  }
  
  # Prüfung auf gültige Zahlen in n_seats_sum
  if ("n_seats_sum" %in% names(df)) {
    valid_rows <- !is.na(df$n_seats_sum) & is.finite(as.numeric(df$n_seats_sum))
    if (any(!valid_rows)) {
      last_valid_row <- which(!valid_rows)[1] - 1
    } else {
      last_valid_row <- nrow(df)
    }
    rows_to_show <- 1:max(1, last_valid_row)
    cat("Zeilen mit Zahlen in 'n_seats_sum' (sortiert):\n")
    print(df[rows_to_show, , drop = FALSE])
  } else {
    cat("Erste 3 Zeilen:\n")
    print(head(df, 3))
  }
  cat("\n\n")
}

# Übersicht für alle Dataframes erstellen
for (name in df_names) {
  df_overview(name)
}




```

### Was wenn - Parolen anwenden

```{r}
#| label: tbd

# year aus Datum auslesen/hinzufügen als numerischen Wert

elec_nr_sr_lvl_state <- elec_nr_sr_lvl_state %>%
  mutate(year = as.numeric(year))

elec_kanton_lvl_state <- elec_kanton_lvl_state %>%
  mutate(year = as.numeric(year))

elec_gemeinde_lvl_state <- elec_gemeinde_lvl_state %>%
  mutate(year = as.numeric(year))


# Spalten selektionieren und Parteistärkem dazu laden
voting_5y_party_strength <- voting_5y_long %>%
  filter(!grepl("^pdev-", variable)) %>%      # pdev- vorläufig ausschliessen
  mutate(year = as.numeric(year(datum))) %>% 
  select("anr",
         "year",
         "datum",
         "titel_kurz_d",
         "rechtsform",
         "dep",
         "annahme",
         "berecht",
         "stimmen",
         "bet",       # Stimmbeteiligung
         "leer",
         "ungultig",
         "gultig",
         "volkja",
         "volknein",
         "volkja-proz",
         "Partei",
         "parole_Nein",
         "parole_Ja",
         "parole_keine",
         ) %>%
  
  #National- und Ständerat
  left_join(
    elec_nr_sr_lvl_state %>%
      select(year, Partei, n_seats_sum, n_seats_pct) %>%
      rename(n_seats_state = n_seats_sum,
             n_seats_pct_state = n_seats_pct),
        by = c("year", "Partei")) %>%
  #Kanton
  left_join(
    elec_kanton_lvl_state %>%
      select(year, Partei,
             n_seats_sum, n_seats_pct,
             n_seats_sum_weighted, n_seats_pct_weighted,) %>%
      rename(n_seats_kanton = n_seats_sum,
             n_seats_pct_kanton = n_seats_pct,
             n_seats_sum_weighted_kt = n_seats_sum_weighted,
             n_seats_pct_weighted_kt = n_seats_pct_weighted,
             ),
        by = c("year", "Partei")) %>%
  #Gemeinde
  left_join(
    elec_gemeinde_lvl_state %>%
      select(year, Partei,
             n_seats_sum, n_seats_pct,
             n_seats_sum_weighted, n_seats_pct_weighted,) %>%
      rename(n_seats_gemeinde = n_seats_sum,
             n_seats_pct_gemeinde = n_seats_pct,
             n_seats_sum_weighted_gemeinde = n_seats_sum_weighted,
             n_seats_pct_weighted_gemeinde = n_seats_pct_weighted,
             ),
        by = c("year", "Partei")) %>% 
  filter(!is.na(Partei))


write_xlsx(voting_5y_party_strength, "test_voting_5y_party_strength.xlsx")


# Parteistärke anwenden und aufsummieren

#Neue Spalten mit den gewichteten Parolen berechnen
voting_5y_party_strength_weighted <- voting_5y_party_strength %>%
  mutate(
    parole_Nein_wtd_state     = parole_Nein   * n_seats_pct_state,
    parole_Ja_wtd_state       = parole_Ja     * n_seats_pct_state,
    parole_Keine_wtd_state    = parole_keine  * n_seats_pct_state,
    
    parole_Nein_wtd_kt        = parole_Nein   * n_seats_pct_weighted_kt,
    parole_Ja_wtd_kt          = parole_Ja     * n_seats_pct_weighted_kt,
    parole_Keine_wtd_kt       = parole_keine  * n_seats_pct_weighted_kt,
    
    parole_Nein_wtd_gem       = parole_Nein   * n_seats_pct_weighted_gemeinde,
    parole_Ja_wtd_gem         = parole_Ja     * n_seats_pct_weighted_gemeinde,
    parole_Keine_wtd_gem      = parole_keine  * n_seats_pct_weighted_gemeinde)

#Gruppieren und aufsummieren nach anr und year
voting_5y_party_strength_summary <- voting_5y_party_strength_weighted %>%
  group_by(anr, year, annahme) %>%
  summarise(
    state_parole_Nein       = sum(parole_Nein_wtd_state, na.rm = TRUE),
    state_parole_Ja         = sum(parole_Ja_wtd_state, na.rm = TRUE),
    state_parole_Keine      = sum(parole_Keine_wtd_state, na.rm = TRUE),
    
    kt_parole_Nein          = sum(parole_Nein_wtd_kt, na.rm = TRUE),
    kt_parole_Ja            = sum(parole_Ja_wtd_kt, na.rm = TRUE),
    kt_parole_Keine         = sum(parole_Keine_wtd_kt, na.rm = TRUE),
    
    gemeinde_parole_Nein    = sum(parole_Nein_wtd_gem, na.rm = TRUE),
    gemeinde_parole_Ja      = sum(parole_Ja_wtd_gem, na.rm = TRUE),
    gemeinde_parole_Keine   = sum(parole_Keine_wtd_gem, na.rm = TRUE),
    .groups = "drop"
  )



# Zusatzinformationen wieder dazu joinen 



```

```{r}
#| label: tbd

# Beispiel: für das Jahr 2020
jahr <- 2020

df_plot <- voting_5y_party_strength_summary %>%
  filter(year == jahr) %>%
  select(anr, starts_with("state_parole_")) %>%
  pivot_longer(
    cols = starts_with("state_parole_"),
    names_to = "parole_typ",
    values_to = "wert"
  ) %>%
  mutate(
    parole_typ = case_when(
      grepl("_Nein$", parole_typ) ~ "Nein",
      grepl("_Ja$", parole_typ) ~ "Ja",
      grepl("_Keine$", parole_typ) ~ "Keine"
    ),
    anr = factor(anr, levels = unique(anr)) # Reihenfolge fixieren
  )

# Plot: jede Zeile ist eine Abstimmung (anr), Balken zeigt die Verteilung Nein/Ja/Keine
ggplot(df_plot, aes(x = anr, y = wert, fill = parole_typ)) +
  geom_bar(stat = "identity", position = "fill", width = 1) +
  scale_y_continuous(labels = scales::percent_format()) +
  coord_flip() +
  labs(
    x = "Abstimmung (anr)",
    y = "Anteil",
    fill = "Parole",
    title = paste("Verteilung Ja/Nein/Keine pro Abstimmung –", jahr)
  ) +
  theme_minimal()


```

```{r}

# Tatsächliches Abstiummungsergebnis (annahme) auch abbilden

jahr <- 2020

# Daten für den Balkenplot vorbereiten
df_plot <- voting_5y_party_strength_summary %>%
  filter(year == jahr) %>%
  select(anr, starts_with("state_parole_")) %>%
  pivot_longer(
    cols = starts_with("state_parole_"),
    names_to = "parole_typ",
    values_to = "wert"
  ) %>%
  mutate(
    parole_typ = case_when(
      grepl("_Nein$", parole_typ) ~ "Nein",
      grepl("_Ja$", parole_typ) ~ "Ja",
      grepl("_Keine$", parole_typ) ~ "Keine"
    ),
    anr = factor(anr, levels = unique(anr)) # Reihenfolge fixieren
  )

# Annahme-Daten für die Punkte vorbereiten
df_annahme <- voting_5y_party_strength_summary %>%
  filter(year == jahr) %>%
  select(anr, annahme) %>%
  mutate(
    anr = factor(anr, levels = unique(df_plot$anr)),
    annahme = as.numeric(annahme) # Annahme: 0 oder 1
  )

# Plot mit Balken und Annahme-Punkt
ggplot() +
  geom_bar(
    data = df_plot,
    mapping = aes(x = anr, y = wert, fill = parole_typ),
    stat = "identity",
    position = "fill",
    width = 1
  ) +
  geom_point(
    data = df_annahme,
    mapping = aes(x = anr, y = annahme),
    color = "black", size = 3
  ) +
  scale_y_continuous(labels = scales::percent_format()) +
  coord_flip() +
  labs(
    x = "Abstimmung (anr)",
    y = "Anteil",
    fill = "Parole",
    title = paste("Verteilung Ja/Nein/Keine pro Abstimmung –", jahr)
  ) +
  theme_minimal()



```

```{r}

# tatsächliches Abstiummungsergebnis bei 0 (0) oder 100% (1) als PUnkt darstellen.


jahr <- 2020

df_plot <- voting_5y_party_strength_summary %>%
  filter(year == jahr) %>%
  select(anr, 
         starts_with("state_parole_"), 
         starts_with("kt_parole_"), 
         starts_with("gemeinde_parole_")) %>%
  pivot_longer(
    cols = -anr,
    names_to = "parole_spalte",
    values_to = "wert"
  ) %>%
  mutate(
    # Parole-Typ extrahieren (Ja/Nein/Keine)
    parole_typ = case_when(
      grepl("_Nein$", parole_spalte) ~ "Nein",
      grepl("_Ja$", parole_spalte) ~ "Ja",
      grepl("_Keine$", parole_spalte) ~ "Keine"
    ),
    # Parolen-Ebene extrahieren (state/kt/gemeinde)
    parole_ebene = case_when(
      grepl("^state_parole_", parole_spalte) ~ "Bund",
      grepl("^kt_parole_", parole_spalte) ~ "Kanton",
      grepl("^gemeinde_parole_", parole_spalte) ~ "Gemeinde"
    ),
    anr = factor(anr, levels = unique(anr))
  )

# Beispielplot: Facetten nach Parolenebene
ggplot(df_plot, aes(x = anr, y = wert, fill = parole_typ)) +
  geom_bar(stat = "identity", position = "fill", width = 1) +
  scale_y_continuous(labels = scales::percent_format()) +
  coord_flip() +
  facet_wrap(~parole_ebene, ncol = 1) +
  labs(
    x = "Abstimmung (anr)",
    y = "Anteil",
    fill = "Parole",
    title = paste("Verteilung Ja/Nein/Keine pro Abstimmung –", jahr)
  ) +
  theme_minimal()


```

```{r}

# nicht nur state_parole_ sondern auch kt_parole_ und gemeinde_parole_ anzeigen.

jahr <- 2020

# Daten für den Balkenplot vorbereiten (alle parole-Spalten, Quelle extrahieren)
df_plot <- voting_5y_party_strength_summary %>%
  filter(year == jahr) %>%
  select(anr, matches("^(state|kt|gemeinde)_parole_")) %>%
  pivot_longer(
    cols = matches("^(state|kt|gemeinde)_parole_"),
    names_to = "parole_typ",
    values_to = "wert"
  ) %>%
  mutate(
    parole_quelle = case_when(
      grepl("^state_parole_", parole_typ) ~ "Kanton",
      grepl("^kt_parole_", parole_typ) ~ "Kantonale Partei",
      grepl("^gemeinde_parole_", parole_typ) ~ "Gemeinde"
    ),
    parole_typ = case_when(
      grepl("_Nein$", parole_typ) ~ "Nein",
      grepl("_Ja$", parole_typ) ~ "Ja",
      grepl("_Keine$", parole_typ) ~ "Keine"
    ),
    anr = factor(anr, levels = unique(anr)),
    parole_quelle = factor(parole_quelle, levels = c("Kanton", "Kantonale Partei", "Gemeinde"))
  )

# Annahme-Daten für die Punkte vorbereiten
df_annahme <- voting_5y_party_strength_summary %>%
  filter(year == jahr) %>%
  select(anr, annahme) %>%
  mutate(
    anr = factor(anr, levels = unique(df_plot$anr)),
    annahme = as.numeric(annahme) # Annahme: 0 oder 1
  )

# Plot mit Balken und Annahme-Punkt, getrennt nach parole_quelle
ggplot() +
  geom_bar(
    data = df_plot,
    mapping = aes(x = anr, y = wert, fill = parole_typ),
    stat = "identity",
    position = "fill",
    width = 1
  ) +
  geom_point(
    data = df_annahme,
    mapping = aes(x = anr, y = annahme),
    color = "black", size = 3
  ) +
  scale_y_continuous(labels = scales::percent_format()) +
  coord_flip() +
  facet_wrap(~ parole_quelle, ncol = 1, scales = "free_y") +
  labs(
    x = "Abstimmung (anr)",
    y = "Anteil",
    fill = "Parole",
    title = paste("Verteilung Ja/Nein/Keine pro Abstimmung –", jahr)
  ) +
  theme_minimal()


```

```{r}

# Gruppierung nach Abstimmung (anr)

jahr <- 2020

# Daten für den Balkenplot vorbereiten (alle parole-Spalten, Quelle extrahieren)
df_plot <- voting_5y_party_strength_summary %>%
  filter(year == jahr) %>%
  select(anr, matches("^(state|kt|gemeinde)_parole_")) %>%
  pivot_longer(
    cols = matches("^(state|kt|gemeinde)_parole_"),
    names_to = "parole_typ",
    values_to = "wert"
  ) %>%
  mutate(
    parole_quelle = case_when(
      grepl("^state_parole_", parole_typ) ~ "Kanton",
      grepl("^kt_parole_", parole_typ) ~ "Kantonale Partei",
      grepl("^gemeinde_parole_", parole_typ) ~ "Gemeinde"
    ),
    parole_typ = case_when(
      grepl("_Nein$", parole_typ) ~ "Nein",
      grepl("_Ja$", parole_typ) ~ "Ja",
      grepl("_Keine$", parole_typ) ~ "Keine"
    ),
    parole_quelle = factor(parole_quelle, levels = c("Kanton", "Kantonale Partei", "Gemeinde")),
    anr = factor(anr, levels = unique(anr))
  )

# Annahme-Daten für die Punkte vorbereiten
df_annahme <- voting_5y_party_strength_summary %>%
  filter(year == jahr) %>%
  select(anr, annahme) %>%
  mutate(
    anr = factor(anr, levels = unique(df_plot$anr)),
    annahme = as.numeric(annahme)
  )

# Plot: Gruppierung nach Abstimmung (anr)
ggplot() +
  geom_bar(
    data = df_plot,
    mapping = aes(x = parole_quelle, y = wert, fill = parole_typ),
    stat = "identity",
    position = "fill",
    width = 0.7
  ) +
  geom_point(
    data = df_annahme,
    mapping = aes(x = 2, y = annahme), # x=2: Punkt mittig bei "Kantonale Partei"
    color = "black", size = 3, inherit.aes = FALSE
  ) +
  scale_y_continuous(labels = scales::percent_format()) +
  facet_wrap(~ anr, ncol = 1) +
  labs(
    x = "Quelle der Parole",
    y = "Anteil",
    fill = "Parole",
    title = paste("Verteilung Ja/Nein/Keine nach Quelle pro Abstimmung –", jahr)
  ) +
  theme_minimal()

# TODO: Nicht nur pro Jahr sondern auch Departement? Tatsächliche ja/nein/enthalten hinzufügen.
```

## Parteilandschaft

### Multi-Dimensions-Model

#### Minimalwerte

Für jede Partei den Minimalwert des Abstimmungsverhaltens zu verwenden, basiert auf der Zielsetzung, die klarste politische Position einer Partei in einem bestimmten Themenbereich zu identifizieren. Diese Methodik stellt sicher, dass auch bei wenigen Abweichungen von der Mehrheitslinie die tatsächliche Haltung der Partei deutlich erkennbar bleibt.

```{r}
#| label: tbd

ggplot(parties_rating,
       aes(x = eco_pct_min_x,
           y = socio_pct_min_y,
           label = Partei)) +
  geom_point(size = 3) +
  geom_text(vjust = -0.8) +
  geom_segment(aes(x = 50, xend = 50,
                   y = 0, yend = 100), linetype = "dashed", color = "blue") +
  geom_segment(aes(x = 0, xend = 100,
                   y = 50, yend = 50), linetype = "dashed", color = "blue") +
  
  annotate("text",
           x = 0,
           y = min(parties_rating$socio_pct_min_y) + 55,
           label = "Links/staatsgläubig", size = 4, hjust = 0.5) +
  annotate("text",
           x = 100,
           y = min(parties_rating$socio_pct_min_y) + 55,
           label = "Rechts/marktwirtschaftlich", size = 4, hjust = 0.5) +
  annotate("text",
           x = 50,
           y = min(parties_rating$socio_pct_min_y) - 3,
           label = "Autoritär/Konservativ", size = 4, hjust = 0.5) +
  annotate("text",
           x = 50,
           y = min(parties_rating$socio_pct_min_y) + 103,
           label = "Libertär/Progressiv", size = 4, hjust = 0.5) +
  scale_x_continuous(limits = c(0, 100)) +
  labs(x = "Wirtschaftspolitisch",
       y = "Gesellschaftspolitisch",
       title = "Politische Positionierung im Zwei-Achsen-Modell",
       subtitle = "Grundlage: Minimalwerte des Abstimmungsverhaltens") +
  theme_minimal()+
  theme(plot.title = element_text(size = 18,
                                  margin = margin(b = 30)),
        axis.title.x = element_text(size = 14,
                                    margin = margin(t = 5)),
        axis.title.y = element_text(size = 14,
                                    margin = margin(r = 5))) +
  coord_cartesian(ylim = c(0, 105),
                  xlim = c(0, 105),
                  clip = "off")
```

#### Durchschnittswerte als Zentrum und Min/Max als Ellipse

```{r}
#| label: tbd

ggplot(parties_rating,
       aes(x = eco_pct_avg_x,
           y = socio_pct_avg_y,
           label = Partei)) +
  geom_ellipse(
    aes(x0 = eco_pct_avg_x,
        y0 = socio_pct_avg_y,
        a = (eco_pct_max_x - eco_pct_min_x) / 2, # Halbachse x
        b = (socio_pct_max_y - socio_pct_min_y) / 2, # Halbachse y
        angle = 0),
    fill = "gray80", alpha = 0.4) +
  geom_point(size = 3) +
  geom_text(vjust = -0.8) +
  geom_segment(aes(x = 50, xend = 50,
                   y = 0, yend = 100), linetype = "dashed", color = "blue") +
  geom_segment(aes(x = 0, xend = 100,
                   y = 50, yend = 50), linetype = "dashed", color = "blue") +
  annotate("text",
           x = 0,
           y = min(parties_rating$socio_pct_min_y) + 55,
           label = "Links/staatsgläubig", size = 4, hjust = 0.5) +
  annotate("text",
           x = 100,
           y = min(parties_rating$socio_pct_min_y) + 55,
           label = "Rechts/marktwirtschaftlich", size = 4, hjust = 0.5) +
  annotate("text",
           x = 50,
           y = min(parties_rating$socio_pct_min_y) - 3,
           label = "Autoritär/Konservativ", size = 4, hjust = 0.5) +
  annotate("text",
           x = 50,
           y = min(parties_rating$socio_pct_min_y) + 103,
           label = "Libertär/Progressiv", size = 4, hjust = 0.5) +
  scale_x_continuous(limits = c(-10, +110)) +
  labs(x = "Wirtschaftspolitisch",
       y = "Gesellschaftspolitisch",
       title = "Politische Positionierung im Zwei-Achsen-Modell",
       subtitle = "Grundlage: Durchschnitt des Abstimmungsverhaltens als Zentrum, Min-/Max als Ellipse") +
  theme_minimal()+
  theme(plot.title = element_text(size = 18,
                                  margin = margin(b = 30)),
        axis.title.x = element_text(size = 14,
                                    margin = margin(t = 5)),
        axis.title.y = element_text(size = 14,
                                    margin = margin(r = 5))) +
  coord_cartesian(ylim = c(0, 100),
                  xlim = c(0, 100),
                  clip = "off")
```

#### Hauptparteien: Durchschnittswerte als Zentrum und Min/Max als Ellipse / Klein- und Regionalparteien nur mit ihrem Durchschnittswert

```{r}
#| label: tbd

ggplot(parties_rating,
       aes(x = eco_pct_avg_x,
           y = socio_pct_avg_y,
           label = Partei)) +
  geom_ellipse(aes(x0 = eco_pct_avg_x,
                   y0 = socio_pct_avg_y,
                   a = (eco_pct_max_x - eco_pct_min_x) / 2, # Halbachse x
                   b = (socio_pct_max_y - socio_pct_min_y) / 2, # Halbachse y
                   angle = 0),
               fill = "gray80", alpha = 0.4) +
  geom_point(size = 3) +
  
  # Kleinere Parteien
  geom_point(data = subset(parties_rating,
                           `Grosse Partei` == "n" &
                             Relevanz_nationale_Abstimmungen != "-"),
             aes(x = eco_x,
                 y = socio_y),
             shape = 21, fill = "grey", color = "black", size = 1, stroke = 1) +
  
  # Labels der kleineren Partein
  geom_text(data = subset(parties_rating,
                          `Grosse Partei` == "n" &
                            Relevanz_nationale_Abstimmungen != "-"),
            aes(x = eco_x,
                y = socio_y,
                label = Partei),
            vjust = -1, fontface = "plain", color = "darkgrey") +
  geom_text(vjust = -0.8) +
  geom_segment(aes(x = 50, xend = 50,
                   y = 0, yend = 100), linetype = "dashed", color = "blue") +
  geom_segment(aes(x = 0, xend = 100,
                   y = 50, yend = 50), linetype = "dashed", color = "blue") +
  annotate("text",
           x = 0,
           y = min(parties_rating$socio_pct_min_y) + 55,
           label = "Links/staatsgläubig", size = 4, hjust = 0.5) +
  annotate("text",
           x = 100,
           y = min(parties_rating$socio_pct_min_y) + 55,
           label = "Rechts/marktwirtschaftlich", size = 4, hjust = 0.5) +
  annotate("text",
           x = 50,
           y = min(parties_rating$socio_pct_min_y) - 3,
           label = "Autoritär/Konservativ", size = 4, hjust = 0.5) +
  annotate("text",
           x = 50,
           y = min(parties_rating$socio_pct_min_y) + 103,
           label = "Libertär/Progressiv", size = 4, hjust = 0.5) +
  scale_x_continuous(limits = c(-10, +110)) +
  labs(x = "Wirtschaftspolitisch",
       y = "Gesellschaftspolitisch",
       title = "Politische Positionierung im Zwei-Achsen-Modell",
       subtitle = "Durchschnitt des Abstimmungsverhaltens als Zentrum, Min-/Max als Ellipse") +
  theme_minimal()+
  theme(plot.title = element_text(size = 18,
                                  margin = margin(b = 30)),
        axis.title.x = element_text(size = 14,
                                    margin = margin(t = 5)),
        axis.title.y = element_text(size = 14,
                                    margin = margin(r = 5))) +
  coord_cartesian(ylim = c(0, 100),
                  xlim = c(0, 100),
                  clip = "off")
```

#### Hauptparteien: Durchschnittswerte als Zentrum und Min/Max als Ellipse / Verbände sowie Klein- und Regionalparteien nur mit ihrem Durchschnittswert

```{r}
#| label: tbd

ggplot(parties_rating,
       aes(x = eco_pct_avg_x,
           y = socio_pct_avg_y,
           label = Partei)) +
  geom_ellipse(
    aes(x0 = eco_pct_avg_x,
        y0 = socio_pct_avg_y,
        a = (eco_pct_max_x - eco_pct_min_x) / 2, # Halbachse x
        b = (socio_pct_max_y - socio_pct_min_y) / 2, # Halbachse y
        angle = 0),
    fill = "gray80", alpha = 0.4) +
  geom_point(size = 3) +
  
  # Kleinere Parteien
  geom_point(data = subset(parties_rating,
                           `Grosse Partei` == "n" #&
                           #Relevanz_nationale_Abstimmungen != "-"
                           )
                  ,
    aes(x = eco_x, y = socio_y),
    shape = 21, fill = "grey", color = "black", size = 1, stroke = 1
  ) +
  # Labels der kleineren Partein
  geom_text(data = subset(parties_rating,
                          `Grosse Partei` == "n" #&
                          #Relevanz_nationale_Abstimmungen != "-"
                  )
                  ,
    aes(x = eco_x, y = socio_y, label = Partei),
    vjust = -1, fontface = "plain", color = "darkgrey"
  ) +

  geom_text(vjust = -0.8) +
  geom_segment(aes(x = 50, xend = 50,
                   y = 0, yend = 100), linetype = "dashed", color = "blue") +
  geom_segment(aes(x = 0, xend = 100,
                   y = 50, yend = 50), linetype = "dashed", color = "blue") +
  annotate("text",
           x = 0,
           y = min(parties_rating$socio_pct_min_y) + 55,
           label = "Links/staatsgläubig", size = 4, hjust = 0.5) +
  annotate("text",
           x = 100,
           y = min(parties_rating$socio_pct_min_y) + 55,
           label = "Rechts/marktwirtschaftlich", size = 4, hjust = 0.5) +
  annotate("text",
           x = 50,
           y = min(parties_rating$socio_pct_min_y) - 3,
           label = "Autoritär/Konservativ", size = 4, hjust = 0.5) +
  annotate("text",
           x = 50,
           y = min(parties_rating$socio_pct_min_y) + 103,
           label = "Libertär/Progressiv", size = 4, hjust = 0.5) +
  scale_x_continuous(limits = c(-10, +110)) +
  labs(x = "Wirtschaftspolitisch",
       y = "Gesellschaftspolitisch",
       title = "Politische Positionierung im Zwei-Achsen-Modell",
       subtitle = "Grundlage: Durchschnitt des Abstimmungsverhaltens als Zentrum, Min-/Max als Ellipse") +
  theme_minimal()+
  theme(plot.title = element_text(size = 18,
                                  margin = margin(b = 30)),
        axis.title.x = element_text(size = 14,
                                    margin = margin(t = 5)),
        axis.title.y = element_text(size = 14,
                                    margin = margin(r = 5))) +
  coord_cartesian(ylim = c(0, 100),
                  xlim = c(0, 100),
                  clip = "off")
```

### 3D-Koordinatensystem (Testweise)

```{r}
#| label: tbd


# Datenframe erstellen
parties <- data.frame(
  Partei = c("SP", "SVP", "FDP", "GPS", "GLP", "Mitte", "EVP", "EDU"),
  Wirtschaft = c(20, 85, 80, 30, 60, 60, 40, 90),      # Links = niedrig, Rechts = hoch
  Gesellschaft = c(90, 20, 55, 90, 75, 45, 50, 20),    # Libertär = hoch, Autoritär = niedrig
  Kosmopolitismus = c(90, 15, 60, 95, 85, 50, 55, 20)  # Kosmopolitisch = hoch, Nationalistisch = niedrig
)

# Interaktives 3D-Scatterplot mit Plotly
fig <- plot_ly(
  data = parties,
  x = ~Wirtschaft,
  y = ~Gesellschaft,
  z = ~Kosmopolitismus,
  text = ~Partei,
  type = 'scatter3d',
  mode = 'markers+text',
  marker = list(size = 5),
  textposition = 'top center'
)

# Achsen benennen und Layout anpassen
fig <- fig %>% layout(
  scene = list(
    xaxis = list(title = "Wirtschaftspolitik (links – rechts)"),
    yaxis = list(title = "Gesellschaftspolitik (autoritär – libertär)"),
    zaxis = list(title = "Kosmopolitismus – Nationalismus")
  ),
  title = "Schweizer Parteien im 3D-Koordinatensystem nach Kitschelt"
)

# Plot anzeigen



```
